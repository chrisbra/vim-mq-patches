# HG changeset patch
# Parent 11e62066065ea5cd09fd684adf0ae65d0b262c3b
* * *
* * *
Add a new 'breakindentopt' setting, that will include all
previous 'breakindent' settings and addtionally make it possible
to configure, how the 'sbr' setting will be drawn.

diff --git a/runtime/doc/eval.txt b/runtime/doc/eval.txt
--- a/runtime/doc/eval.txt
+++ b/runtime/doc/eval.txt
@@ -6651,8 +6651,8 @@ jumplist		Compiled with |jumplist| suppo
 keymap			Compiled with 'keymap' support.
 langmap			Compiled with 'langmap' support.
 libcall			Compiled with |libcall()| support.
-linebreak		Compiled with 'linebreak', 'breakat' and 'showbreak'
-			support.
+linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
+			'breakindent' support.
 lispindent		Compiled with support for lisp indenting.
 listcmds		Compiled with commands for the buffer list |:files|
 			and the argument list |arglist|.
diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -1200,6 +1200,38 @@ A jump table for the options with a shor
 	break if 'linebreak' is on.  Only works for ASCII and also for 8-bit
 	characters when 'encoding' is an 8-bit encoding.
 
+						*'breakindent'* *'bri'*
+'breakindent' 'bri'	boolean (default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Every wrapped line will continue visually indented (same amount of
+	space as the beginning of that line), thus preserving horizontal blocks
+	of text.
+
+						*'breakindentmin'* *'brimin'*
+'breakindentopt' 'briopt' string (default "min:20,shift:0")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Settings for 'breakindent'. It can consist of the following optional
+	items and must be seperated by a comma:
+		min:{n}	    Minimum text width that will be kept after
+			    applying 'breakindent', even if the resulting
+			    text should normally be narrower. This prevents
+			    text indented almost to the right window border
+			    occupying lot of vertical space when broken.
+		shift:{n}   After applying 'breakindent', wrapped line
+			    beginning will be shift by given number of
+			    characters. It permits dynamic French paragraph
+			    indentation (negative) or emphasizing the line
+			    continuation (positive).
+		sbr	    Display the 'showbreak' value before applying the 
+			    additional indent.
+	If empty, the default for min is 20 and shift is 0
+
 						*'browsedir'* *'bsdir'*
 'browsedir' 'bsdir'	string	(default: "last")
 			global
@@ -4574,12 +4606,13 @@ A jump table for the options with a shor
 			{not in Vi}
 			{not available when compiled without the |+linebreak|
 			feature}
-	If on Vim will wrap long lines at a character in 'breakat' rather
+	If on, Vim will wrap long lines at a character in 'breakat' rather
 	than at the last character that fits on the screen.  Unlike
 	'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,
-	it only affects the way the file is displayed, not its contents.  The
-	value of 'showbreak' is used to put in front of wrapped lines.
-	This option is not used when the 'wrap' option is off or 'list' is on.
+	it only affects the way the file is displayed, not its contents.
+	If 'breakindent' is set, line is visually indented. Then, the value
+	of 'showbreak' is used to put in front of wrapped lines. This option
+	is not used when the 'wrap' option is off or 'list' is on.
 	Note that <Tab> characters after an <EOL> are mostly not displayed
 	with the right amount of white space.
 
diff --git a/runtime/optwin.vim b/runtime/optwin.vim
--- a/runtime/optwin.vim
+++ b/runtime/optwin.vim
@@ -324,6 +324,12 @@ call <SID>BinOptionG("wrap", &wrap)
 call append("$", "linebreak\twrap long lines at a character in 'breakat'")
 call append("$", "\t(local to window)")
 call <SID>BinOptionL("lbr")
+call append("$", "breakindent\tpreserve indentation in wrapped text")
+call append("$", "\t(local to window)")
+call <SID>BinOptionL("bri")
+call append("$", "breakindentopt\tadjust breakindent behaviour")
+call append("$", "\t(local to window)")
+call <SID>OptionL("briopt")
 call append("$", "breakat\twhich characters might cause a line break")
 call <SID>OptionG("brk", &brk)
 call append("$", "showbreak\tstring to put before wrapped screen lines")
diff --git a/src/buffer.c b/src/buffer.c
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -2704,6 +2704,9 @@ get_winopts(buf)
 #ifdef FEAT_SYN_HL
     check_colorcolumn(curwin);
 #endif
+#ifdef FEAT_LINEBREAK
+    briopt_check();
+#endif
 }
 
 /*
diff --git a/src/charset.c b/src/charset.c
--- a/src/charset.c
+++ b/src/charset.c
@@ -867,9 +867,10 @@ linetabsize_col(startcol, s)
     char_u	*s;
 {
     colnr_T	col = startcol;
+    char_u	*p = s; /* pointer to start of line, needed for breakindent */
 
     while (*s != NUL)
-	col += lbr_chartabsize_adv(&s, col);
+	col += lbr_chartabsize_adv(&s, col, p);
     return (int)col;
 }
 
@@ -886,7 +887,7 @@ win_linetabsize(wp, p, len)
     char_u	*s;
 
     for (s = p; *s != NUL && (len == MAXCOL || s < p + len); mb_ptr_adv(s))
-	col += win_lbr_chartabsize(wp, s, col, NULL);
+	col += win_lbr_chartabsize(wp, s, col, NULL, p);
     return (int)col;
 }
 
@@ -1021,12 +1022,13 @@ vim_isprintc_strict(c)
  * like chartabsize(), but also check for line breaks on the screen
  */
     int
-lbr_chartabsize(s, col)
+lbr_chartabsize(s, col, p)
     unsigned char	*s;
     colnr_T		col;
+    char_u		*p;
 {
 #ifdef FEAT_LINEBREAK
-    if (!curwin->w_p_lbr && *p_sbr == NUL)
+    if (!curwin->w_p_lbr && *p_sbr == NUL && !curwin->w_p_bri)
     {
 #endif
 #ifdef FEAT_MBYTE
@@ -1036,7 +1038,9 @@ lbr_chartabsize(s, col)
 	RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)
 #ifdef FEAT_LINEBREAK
     }
-    return win_lbr_chartabsize(curwin, s, col, NULL);
+    if (p == NULL)
+	p = s;
+    return win_lbr_chartabsize(curwin, s, col, NULL, p);
 #endif
 }
 
@@ -1044,13 +1048,14 @@ lbr_chartabsize(s, col)
  * Call lbr_chartabsize() and advance the pointer.
  */
     int
-lbr_chartabsize_adv(s, col)
+lbr_chartabsize_adv(s, col, p)
     char_u	**s;
     colnr_T	col;
+    char_u	*p;
 {
     int		retval;
 
-    retval = lbr_chartabsize(*s, col);
+    retval = lbr_chartabsize(*s, col, p);
     mb_ptr_adv(*s);
     return retval;
 }
@@ -1063,11 +1068,12 @@ lbr_chartabsize_adv(s, col)
  * value, init to 0 before calling.
  */
     int
-win_lbr_chartabsize(wp, s, col, headp)
+win_lbr_chartabsize(wp, s, col, headp, p)
     win_T	*wp;
     char_u	*s;
     colnr_T	col;
     int		*headp UNUSED;
+    char_u	*p;
 {
 #ifdef FEAT_LINEBREAK
     int		c;
@@ -1086,9 +1092,9 @@ win_lbr_chartabsize(wp, s, col, headp)
     int		n;
 
     /*
-     * No 'linebreak' and 'showbreak': return quickly.
+     * No 'linebreak', 'showbreak' and 'breakindent': return quickly.
      */
-    if (!wp->w_p_lbr && *p_sbr == NUL)
+    if (!wp->w_p_lbr && !wp->w_p_bri && *p_sbr == NUL)
 #endif
     {
 #ifdef FEAT_MBYTE
@@ -1163,11 +1169,12 @@ win_lbr_chartabsize(wp, s, col, headp)
 # endif
 
     /*
-     * May have to add something for 'showbreak' string at start of line
+     * May have to add something for 'breakindent' and/or 'showbreak'
+     * string at start of line.
      * Set *headp to the size of what we add.
      */
     added = 0;
-    if (*p_sbr != NUL && wp->w_p_wrap && col != 0)
+    if ((*p_sbr != NUL || wp->w_p_bri) && wp->w_p_wrap && col != 0)
     {
 	numberextra = win_col_off(wp);
 	col += numberextra + mb_added;
@@ -1180,7 +1187,12 @@ win_lbr_chartabsize(wp, s, col, headp)
 	}
 	if (col == 0 || col + size > (colnr_T)W_WIDTH(wp))
 	{
-	    added = vim_strsize(p_sbr);
+	    added = 0;
+	    if (*p_sbr != NUL)
+		added += vim_strsize(p_sbr);
+	    if (wp->w_p_bri)
+		added += get_breakindent_win(wp, p);
+
 	    if (tab_corr)
 		size += (added / wp->w_buffer->b_p_ts) * wp->w_buffer->b_p_ts;
 	    else
@@ -1274,13 +1286,14 @@ getvcol(wp, pos, start, cursor, end)
     colnr_T	vcol;
     char_u	*ptr;		/* points to current char */
     char_u	*posptr;	/* points to char at pos->col */
+    char_u	*p;		/* holds complete ptr line */
     int		incr;
     int		head;
     int		ts = wp->w_buffer->b_p_ts;
     int		c;
 
     vcol = 0;
-    ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
+    p = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
     if (pos->col == MAXCOL)
 	posptr = NULL;  /* continue until the NUL */
     else
@@ -1288,12 +1301,13 @@ getvcol(wp, pos, start, cursor, end)
 
     /*
      * This function is used very often, do some speed optimizations.
-     * When 'list', 'linebreak' and 'showbreak' are not set use a simple loop.
+     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set
+     * use a simple loop.
      * Also use this when 'list' is set but tabs take their normal size.
      */
     if ((!wp->w_p_list || lcs_tab1 != NUL)
 #ifdef FEAT_LINEBREAK
-	    && !wp->w_p_lbr && *p_sbr == NUL
+	    && !wp->w_p_lbr && *p_sbr == NUL && !wp->w_p_bri
 #endif
        )
     {
@@ -1355,7 +1369,7 @@ getvcol(wp, pos, start, cursor, end)
 	{
 	    /* A tab gets expanded, depending on the current column */
 	    head = 0;
-	    incr = win_lbr_chartabsize(wp, ptr, vcol, &head);
+	    incr = win_lbr_chartabsize(wp, ptr, vcol, &head, p);
 	    /* make sure we don't go past the end of the line */
 	    if (*ptr == NUL)
 	    {
diff --git a/src/edit.c b/src/edit.c
--- a/src/edit.c
+++ b/src/edit.c
@@ -1956,7 +1956,7 @@ change_indent(type, amount, round, repla
 	    else
 #endif
 		++new_cursor_col;
-	    vcol += lbr_chartabsize(ptr + new_cursor_col, (colnr_T)vcol);
+	    vcol += lbr_chartabsize(ptr + new_cursor_col, (colnr_T)vcol, ptr);
 	}
 	vcol = last_vcol;
 
@@ -7126,9 +7126,10 @@ oneleft()
 	for (;;)
 	{
 	    coladvance(v - width);
-	    /* getviscol() is slow, skip it when 'showbreak' is empty and
-	     * there are no multi-byte characters */
-	    if ((*p_sbr == NUL
+	    /* getviscol() is slow, skip it when 'showbreak' is empty,
+	     * 'breakindent' is not set and there are no multi-byte
+	     * characters */
+	    if ((*p_sbr == NUL && !curwin->w_p_bri
 #  ifdef FEAT_MBYTE
 			&& !has_mbyte
 #  endif
@@ -9758,11 +9759,11 @@ ins_tab()
 	getvcol(curwin, &fpos, &vcol, NULL, NULL);
 	getvcol(curwin, cursor, &want_vcol, NULL, NULL);
 
-	/* Use as many TABs as possible.  Beware of 'showbreak' and
-	 * 'linebreak' adding extra virtual columns. */
+	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
+	 * and 'linebreak' adding extra virtual columns. */
 	while (vim_iswhite(*ptr))
 	{
-	    i = lbr_chartabsize((char_u *)"\t", vcol);
+	    i = lbr_chartabsize((char_u *)"\t", vcol, NULL);
 	    if (vcol + i > want_vcol)
 		break;
 	    if (*ptr != TAB)
@@ -9784,11 +9785,12 @@ ins_tab()
 	if (change_col >= 0)
 	{
 	    int repl_off = 0;
+	    char_u *p = ptr;
 
 	    /* Skip over the spaces we need. */
 	    while (vcol < want_vcol && *ptr == ' ')
 	    {
-		vcol += lbr_chartabsize(ptr, vcol);
+		vcol += lbr_chartabsize(ptr, vcol, p);
 		++ptr;
 		++repl_off;
 	    }
@@ -10029,6 +10031,7 @@ ins_copychar(lnum)
     int	    c;
     int	    temp;
     char_u  *ptr, *prev_ptr;
+    char_u  *p;
 
     if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)
     {
@@ -10038,13 +10041,13 @@ ins_copychar(lnum)
 
     /* try to advance to the cursor column */
     temp = 0;
-    ptr = ml_get(lnum);
+    p = ptr = ml_get(lnum);
     prev_ptr = ptr;
     validate_virtcol();
     while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)
     {
 	prev_ptr = ptr;
-	temp += lbr_chartabsize_adv(&ptr, (colnr_T)temp);
+	temp += lbr_chartabsize_adv(&ptr, (colnr_T)temp, p);
     }
     if ((colnr_T)temp > curwin->w_virtcol)
 	ptr = prev_ptr;
diff --git a/src/ex_getln.c b/src/ex_getln.c
--- a/src/ex_getln.c
+++ b/src/ex_getln.c
@@ -2295,10 +2295,10 @@ getexmodeline(promptc, cookie, indent)
 
 		p = (char_u *)line_ga.ga_data;
 		p[line_ga.ga_len] = NUL;
-		indent = get_indent_str(p, 8);
+		indent = get_indent_str(p, 8, FALSE);
 		indent += sw - indent % sw;
 add_indent:
-		while (get_indent_str(p, 8) < indent)
+		while (get_indent_str(p, 8, FALSE) < indent)
 		{
 		    char_u *s = skipwhite(p);
 
@@ -2350,11 +2350,11 @@ redraw:
 		else
 		{
 		    p[line_ga.ga_len] = NUL;
-		    indent = get_indent_str(p, 8);
+		    indent = get_indent_str(p, 8, FALSE);
 		    --indent;
 		    indent -= indent % get_sw_value(curbuf);
 		}
-		while (get_indent_str(p, 8) > indent)
+		while (get_indent_str(p, 8, FALSE) > indent)
 		{
 		    char_u *s = skipwhite(p);
 
diff --git a/src/getchar.c b/src/getchar.c
--- a/src/getchar.c
+++ b/src/getchar.c
@@ -2676,7 +2676,7 @@ vgetorpeek(advance)
 				    if (!vim_iswhite(ptr[col]))
 					curwin->w_wcol = vcol;
 				    vcol += lbr_chartabsize(ptr + col,
-							       (colnr_T)vcol);
+							       (colnr_T)vcol, ptr);
 #ifdef FEAT_MBYTE
 				    if (has_mbyte)
 					col += (*mb_ptr2len)(ptr + col);
diff --git a/src/misc1.c b/src/misc1.c
--- a/src/misc1.c
+++ b/src/misc1.c
@@ -32,7 +32,7 @@ static garray_T	ga_users;
     int
 get_indent()
 {
-    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts);
+    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);
 }
 
 /*
@@ -42,7 +42,7 @@ get_indent()
 get_indent_lnum(lnum)
     linenr_T	lnum;
 {
-    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts);
+    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);
 }
 
 #if defined(FEAT_FOLDING) || defined(PROTO)
@@ -55,7 +55,7 @@ get_indent_buf(buf, lnum)
     buf_T	*buf;
     linenr_T	lnum;
 {
-    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts);
+    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);
 }
 #endif
 
@@ -64,16 +64,23 @@ get_indent_buf(buf, lnum)
  * 'tabstop' at "ts"
  */
     int
-get_indent_str(ptr, ts)
+get_indent_str(ptr, ts, list)
     char_u	*ptr;
     int		ts;
+    int		list; /* if TRUE, count only screen size for tabs */
 {
     int		count = 0;
 
     for ( ; *ptr; ++ptr)
     {
-	if (*ptr == TAB)    /* count a tab for what it is worth */
-	    count += ts - (count % ts);
+	if (*ptr == TAB)
+	{
+	    if (!list || lcs_tab1)    /* count a tab for what it is worth */
+		count += ts - (count % ts);
+	    else
+	/* in list mode, when tab is not set, count screen char width for Tab: ^I */
+		count += ptr2cells(ptr);
+	}
 	else if (*ptr == ' ')
 	    ++count;		/* count a space for one */
 	else
@@ -476,6 +483,57 @@ get_number_indent(lnum)
     return (int)col;
 }
 
+#ifdef FEAT_LINEBREAK
+/*
+ * Return appropriate space number for breakindent, taking influencing
+ * parameters into account. Window must be specified, since it is not
+ * necessarily always the current one.
+ */
+    int
+get_breakindent_win(wp, s)
+    win_T	*wp;
+    char_u	*s;
+{
+    static int	    indent = 0;  /* cached indent value */
+    static long	    ts     = 0L; /* if tabstop changes, need to refresh indent */
+    static char_u   *ptr = NULL; /* cached pointer to string */
+    int bri = 0;
+    /* window width minus window margin space, i.e. what rests for text */
+    const int eff_wwidth = W_WIDTH(wp) -
+	((wp->w_p_nu || wp->w_p_rnu) &&
+	 (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)
+						? number_width(wp) + 1 : 0);
+
+    if (ptr != s || ts != wp->w_buffer->b_p_ts)
+    {
+	/* line changed, so must refresh indent */
+	ptr = s;
+	indent = get_indent_str(ptr, (int)wp->w_buffer->b_p_ts, wp->w_p_list) + wp->w_p_brishift;
+	ts = wp->w_buffer->b_p_ts;
+    }
+
+    bri = indent;
+    /* minus the length of the showbreak string */
+    if (wp->w_p_brisbr)
+	bri -= vim_strsize(p_sbr);
+
+    /* Add offset for number column, if 'n' is in 'cpoptions' */
+    bri += win_col_off2(wp);
+
+    /* never indent past left window margin */
+    if (bri < 0)
+	bri = 0;
+    /* always leave at least bri_min characters on the left,
+     * if text width is sufficient */
+    else if (bri > eff_wwidth - wp->w_p_brimin)
+	bri = (eff_wwidth - wp->w_p_brimin < 0)
+			    ? 0 : eff_wwidth - wp->w_p_brimin;
+
+    return bri;
+}
+#endif
+
+
 #if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
 
 static int cin_is_cinword __ARGS((char_u *line));
@@ -678,7 +736,7 @@ open_line(dir, flags, second_line_indent
 	/*
 	 * count white space on current line
 	 */
-	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts);
+	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);
 	if (newindent == 0 && !(flags & OPENLINE_COM_LIST))
 	    newindent = second_line_indent; /* for ^^D command in insert mode */
 
@@ -1201,7 +1259,7 @@ open_line(dir, flags, second_line_indent
 					|| do_si
 #endif
 							   )
-			newindent = get_indent_str(leader, (int)curbuf->b_p_ts);
+			newindent = get_indent_str(leader, (int)curbuf->b_p_ts, FALSE);
 
 		    /* Add the indent offset */
 		    if (newindent + off < 0)
@@ -1994,6 +2052,7 @@ plines_win_col(wp, lnum, column)
     char_u	*s;
     int		lines = 0;
     int		width;
+    char_u	*p;
 
 #ifdef FEAT_DIFF
     /* Check for filler lines above this buffer line.  When folded the result
@@ -2009,12 +2068,12 @@ plines_win_col(wp, lnum, column)
 	return lines + 1;
 #endif
 
-    s = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    p = s = ml_get_buf(wp->w_buffer, lnum, FALSE);
 
     col = 0;
     while (*s != NUL && --column >= 0)
     {
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL);
+	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL, p);
 	mb_ptr_adv(s);
     }
 
@@ -2026,7 +2085,7 @@ plines_win_col(wp, lnum, column)
      * 'ts') -- webb.
      */
     if (*s == TAB && (State & NORMAL) && (!wp->w_p_list || lcs_tab1))
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL) - 1;
+	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL, p) - 1;
 
     /*
      * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
@@ -9002,10 +9061,11 @@ get_lisp_indent()
 		amount = 2;
 	    else
 	    {
+		char_u *p = that;
 		amount = 0;
 		while (*that && col)
 		{
-		    amount += lbr_chartabsize_adv(&that, (colnr_T)amount);
+		    amount += lbr_chartabsize_adv(&that, (colnr_T)amount, p);
 		    col--;
 		}
 
@@ -9028,7 +9088,7 @@ get_lisp_indent()
 
 		    while (vim_iswhite(*that))
 		    {
-			amount += lbr_chartabsize(that, (colnr_T)amount);
+			amount += lbr_chartabsize(that, (colnr_T)amount, p);
 			++that;
 		    }
 
@@ -9067,14 +9127,14 @@ get_lisp_indent()
 				    --parencount;
 				if (*that == '\\' && *(that+1) != NUL)
 				    amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
+							     (colnr_T)amount, p);
 				amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
+							     (colnr_T)amount, p);
 			    }
 			}
 			while (vim_iswhite(*that))
 			{
-			    amount += lbr_chartabsize(that, (colnr_T)amount);
+			    amount += lbr_chartabsize(that, (colnr_T)amount, p);
 			    that++;
 			}
 			if (!*that || *that == ';')
diff --git a/src/misc2.c b/src/misc2.c
--- a/src/misc2.c
+++ b/src/misc2.c
@@ -201,10 +201,10 @@ coladvance2(pos, addspaces, finetune, wc
 	{
 	    /* Count a tab for what it's worth (if list mode not on) */
 #ifdef FEAT_LINEBREAK
-	    csize = win_lbr_chartabsize(curwin, ptr, col, &head);
+	    csize = win_lbr_chartabsize(curwin, ptr, col, &head, line);
 	    mb_ptr_adv(ptr);
 #else
-	    csize = lbr_chartabsize_adv(&ptr, col);
+	    csize = lbr_chartabsize_adv(&ptr, col, line);
 #endif
 	    col += csize;
 	}
diff --git a/src/ops.c b/src/ops.c
--- a/src/ops.c
+++ b/src/ops.c
@@ -420,7 +420,7 @@ shift_block(oap, amount)
 	}
 	for ( ; vim_iswhite(*bd.textstart); )
 	{
-	    incr = lbr_chartabsize_adv(&bd.textstart, (colnr_T)(bd.start_vcol));
+	    incr = lbr_chartabsize_adv(&bd.textstart, (colnr_T)(bd.start_vcol), bd.textstart);
 	    total += incr;
 	    bd.start_vcol += incr;
 	}
@@ -480,7 +480,7 @@ shift_block(oap, amount)
 
 	while (vim_iswhite(*non_white))
 	{
-	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
+	    incr = lbr_chartabsize_adv(&non_white, non_white_col, bd.textstart);
 	    non_white_col += incr;
 	}
 
@@ -505,7 +505,8 @@ shift_block(oap, amount)
 	    verbatim_copy_width -= bd.start_char_vcols;
 	while (verbatim_copy_width < destination_col)
 	{
-	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
+	    char_u *p = verbatim_copy_end;
+	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width, p);
 	    if (verbatim_copy_width + incr > destination_col)
 		break;
 	    verbatim_copy_width += incr;
@@ -3617,7 +3618,7 @@ do_put(regname, dir, count, flags)
 	    for (ptr = oldp; vcol < col && *ptr; )
 	    {
 		/* Count a tab for what it's worth (if list mode not on) */
-		incr = lbr_chartabsize_adv(&ptr, (colnr_T)vcol);
+		incr = lbr_chartabsize_adv(&ptr, (colnr_T)vcol, oldp);
 		vcol += incr;
 	    }
 	    bd.textcol = (colnr_T)(ptr - oldp);
@@ -3651,7 +3652,7 @@ do_put(regname, dir, count, flags)
 	    /* calculate number of spaces required to fill right side of block*/
 	    spaces = y_width + 1;
 	    for (j = 0; j < yanklen; j++)
-		spaces -= lbr_chartabsize(&y_array[i][j], 0);
+		spaces -= lbr_chartabsize(&y_array[i][j], 0, NULL);
 	    if (spaces < 0)
 		spaces = 0;
 
@@ -5203,7 +5204,7 @@ block_prep(oap, bdp, lnum, is_del)
     while (bdp->start_vcol < oap->start_vcol && *pstart)
     {
 	/* Count a tab for what it's worth (if list mode not on) */
-	incr = lbr_chartabsize(pstart, (colnr_T)bdp->start_vcol);
+	incr = lbr_chartabsize(pstart, (colnr_T)bdp->start_vcol, line);
 	bdp->start_vcol += incr;
 #ifdef FEAT_VISUALEXTRA
 	if (vim_iswhite(*pstart))
@@ -5272,7 +5273,7 @@ block_prep(oap, bdp, lnum, is_del)
 	    {
 		/* Count a tab for what it's worth (if list mode not on) */
 		prev_pend = pend;
-		incr = lbr_chartabsize_adv(&pend, (colnr_T)bdp->end_vcol);
+		incr = lbr_chartabsize_adv(&pend, (colnr_T)bdp->end_vcol, prev_pend);
 		bdp->end_vcol += incr;
 	    }
 	    if (bdp->end_vcol <= oap->end_vcol
@@ -6882,7 +6883,8 @@ cursor_pos_info()
 	    validate_virtcol();
 	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
 		    (int)curwin->w_virtcol + 1);
-	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
+	    col_print(buf2, sizeof(buf2), (int)STRLEN(p),
+				linetabsize(p));
 
 	    if (char_count_cursor == byte_count_cursor
 		    && char_count == byte_count)
diff --git a/src/option.c b/src/option.c
--- a/src/option.c
+++ b/src/option.c
@@ -188,6 +188,10 @@
 #ifdef FEAT_ARABIC
 # define PV_ARAB	OPT_WIN(WV_ARAB)
 #endif
+#ifdef FEAT_LINEBREAK
+# define PV_BRI		OPT_WIN(WV_BRI)
+# define PV_BRIOPT	OPT_WIN(WV_BRIOPT)
+#endif
 #ifdef FEAT_DIFF
 # define PV_DIFF	OPT_WIN(WV_DIFF)
 #endif
@@ -648,6 +652,24 @@ static struct vimoption
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+    {"breakindent",   "bri",  P_BOOL|P_VI_DEF|P_VIM|P_RWIN,
+#ifdef FEAT_LINEBREAK
+			    (char_u *)VAR_WIN, PV_BRI,
+			    {(char_u *)FALSE, (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+    {"breakindentopt", "briopt", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_COMMA|P_NODUP,
+#ifdef FEAT_LINEBREAK
+			    (char_u *)VAR_WIN, PV_BRIOPT,
+			    {(char_u *)"min:20,shift:0", (char_u *)NULL}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)"", (char_u *)NULL}
+#endif
+			    SCRIPTID_INIT},
     {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
 #ifdef FEAT_BROWSE
 			    (char_u *)&p_bsdir, PV_NONE,
@@ -5709,6 +5731,14 @@ did_set_string_option(opt_idx, varp, new
 		     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)
 	    errmsg = (char_u *)N_("E589: 'backupext' and 'patchmode' are equal");
     }
+#ifdef FEAT_LINEBREAK
+    /* 'breakindentopt' */
+    else if (varp == &curwin->w_p_briopt)
+    {
+	if (briopt_check() == FAIL)
+	    errmsg = e_invarg;
+    }
+#endif
 
     /*
      * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill chartab[]
@@ -10013,6 +10043,8 @@ get_varp(p)
 	case PV_WRAP:	return (char_u *)&(curwin->w_p_wrap);
 #ifdef FEAT_LINEBREAK
 	case PV_LBR:	return (char_u *)&(curwin->w_p_lbr);
+	case PV_BRI:	return (char_u *)&(curwin->w_p_bri);
+	case PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);
 #endif
 #ifdef FEAT_SCROLLBIND
 	case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);
@@ -10202,6 +10234,8 @@ copy_winopt(from, to)
 #endif
 #ifdef FEAT_LINEBREAK
     to->wo_lbr = from->wo_lbr;
+    to->wo_bri = from->wo_bri;
+    to->wo_briopt = vim_strsave(from->wo_briopt);
 #endif
 #ifdef FEAT_SCROLLBIND
     to->wo_scb = from->wo_scb;
@@ -10289,6 +10323,9 @@ check_winopt(wop)
 #ifdef FEAT_CONCEAL
     check_string_option(&wop->wo_cocu);
 #endif
+#ifdef FEAT_LINEBREAK
+    check_string_option(&wop->wo_briopt);
+#endif
 }
 
 /*
@@ -10308,6 +10345,9 @@ clear_winopt(wop)
 # endif
     clear_string_option(&wop->wo_fmr);
 #endif
+#ifdef FEAT_LINEBREAK
+    clear_string_option(&wop->wo_briopt);
+#endif
 #ifdef FEAT_RIGHTLEFT
     clear_string_option(&wop->wo_rlc);
 #endif
@@ -11922,3 +11962,47 @@ find_mps_values(initc, findc, backwards,
 	    ++ptr;
     }
 }
+#ifdef FEAT_LINEBREAK
+/*
+ * This is called when 'breakindentopt' is changed.
+ */
+    int
+briopt_check()
+{
+    char_u	*p;
+    /* Defaults */
+    int		bri_shift = 0;
+    long	bri_min = 0;
+    int		bri_sbr = FALSE;
+
+    p = curwin->w_p_briopt;
+    while (*p != NUL)
+    {
+	if (STRNCMP(p, "shift:", 6) == 0 && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))
+	{
+	    p += 6;
+	    bri_shift = getdigits(&p);
+	}
+	else if (STRNCMP(p, "min:", 4) == 0 && VIM_ISDIGIT(p[4]))
+	{
+	    p += 4;
+	    bri_min = getdigits(&p);
+	}
+	else if (STRNCMP(p, "sbr", 3) == 0)
+	{
+	    p += 3;
+	    bri_sbr = TRUE;
+	}
+	if (*p != ',' && *p != NUL)
+	    return FAIL;
+	if (*p == ',')
+	    ++p;
+    }
+
+    curwin->w_p_brishift = bri_shift;
+    curwin->w_p_brimin   = bri_min;
+    curwin->w_p_brisbr   = bri_sbr;
+
+    return OK;
+}
+#endif
diff --git a/src/option.h b/src/option.h
--- a/src/option.h
+++ b/src/option.h
@@ -1052,6 +1052,10 @@ enum
 #ifdef FEAT_CURSORBIND
     , WV_CRBIND
 #endif
+#ifdef FEAT_LINEBREAK
+    , WV_BRI
+    , WV_BRIOPT
+#endif
 #ifdef FEAT_DIFF
     , WV_DIFF
 #endif
diff --git a/src/proto/charset.pro b/src/proto/charset.pro
--- a/src/proto/charset.pro
+++ b/src/proto/charset.pro
@@ -26,9 +26,9 @@ int vim_isfilec __ARGS((int c));
 int vim_isfilec_or_wc __ARGS((int c));
 int vim_isprintc __ARGS((int c));
 int vim_isprintc_strict __ARGS((int c));
-int lbr_chartabsize __ARGS((unsigned char *s, colnr_T col));
-int lbr_chartabsize_adv __ARGS((char_u **s, colnr_T col));
-int win_lbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
+int lbr_chartabsize __ARGS((unsigned char *s, colnr_T col, char_u *p));
+int lbr_chartabsize_adv __ARGS((char_u **s, colnr_T col, char_u *p));
+int win_lbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp, char_u *p));
 int in_win_border __ARGS((win_T *wp, colnr_T vcol));
 void getvcol __ARGS((win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end));
 colnr_T getvcol_nolist __ARGS((pos_T *posp));
diff --git a/src/proto/misc1.pro b/src/proto/misc1.pro
--- a/src/proto/misc1.pro
+++ b/src/proto/misc1.pro
@@ -2,9 +2,10 @@
 int get_indent __ARGS((void));
 int get_indent_lnum __ARGS((linenr_T lnum));
 int get_indent_buf __ARGS((buf_T *buf, linenr_T lnum));
-int get_indent_str __ARGS((char_u *ptr, int ts));
+int get_indent_str __ARGS((char_u *ptr, int ts, int list));
 int set_indent __ARGS((int size, int flags));
 int get_number_indent __ARGS((linenr_T lnum));
+int get_breakindent_win __ARGS((win_T *wp, char_u *ptr));
 int open_line __ARGS((int dir, int flags, int second_line_indent));
 int get_leader_len __ARGS((char_u *line, char_u **flags, int backward, int include_space));
 int get_last_leader_offset __ARGS((char_u *line, char_u **flags));
diff --git a/src/proto/option.pro b/src/proto/option.pro
--- a/src/proto/option.pro
+++ b/src/proto/option.pro
@@ -63,4 +63,5 @@ int check_ff_value __ARGS((char_u *p));
 long get_sw_value __ARGS((buf_T *buf));
 long get_sts_value __ARGS((void));
 void find_mps_values __ARGS((int *initc, int *findc, int *backwards, int switchit));
+int briopt_check __ARGS((void));
 /* vim: set ft=c : */
diff --git a/src/screen.c b/src/screen.c
--- a/src/screen.c
+++ b/src/screen.c
@@ -2962,10 +2962,15 @@ win_line(wp, lnum, startrow, endrow, noc
 # define WL_SIGN	WL_FOLD		/* column for signs */
 #endif
 #define WL_NR		WL_SIGN + 1	/* line number */
+#ifdef FEAT_LINEBREAK
+# define WL_BRI		WL_NR + 1	/* 'breakindent' */
+#else
+# define WL_BRI		WL_NR
+#endif
 #if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
-# define WL_SBR		WL_NR + 1	/* 'showbreak' or 'diff' */
+# define WL_SBR		WL_BRI + 1	/* 'showbreak' or 'diff' */
 #else
-# define WL_SBR		WL_NR
+# define WL_SBR		WL_BRI
 #endif
 #define WL_LINE		WL_SBR + 1	/* text in the line */
     int		draw_state = WL_START;	/* what to draw next */
@@ -3301,7 +3306,7 @@ win_line(wp, lnum, startrow, endrow, noc
 #endif
 	while (vcol < v && *ptr != NUL)
 	{
-	    c = win_lbr_chartabsize(wp, ptr, (colnr_T)vcol, NULL);
+	    c = win_lbr_chartabsize(wp, ptr, (colnr_T)vcol, NULL, line);
 	    vcol += c;
 #ifdef FEAT_MBYTE
 	    prev_ptr = ptr;
@@ -3670,6 +3675,44 @@ win_line(wp, lnum, startrow, endrow, noc
 		}
 	    }
 
+#ifdef FEAT_LINEBREAK
+	    if (wp->w_p_brisbr && draw_state == WL_BRI - 1 &&
+		    n_extra == 0 && *p_sbr != NUL)
+		/* draw indent after showbreak value */
+		draw_state = WL_BRI;
+	    else if (wp->w_p_brisbr && draw_state == WL_SBR &&
+		    n_extra == 0)
+		/* After the showbreak, draw the breakindent */
+		draw_state = WL_BRI - 1;
+
+	    /* draw 'breakindent': indent wrapped text accordingly */
+	    if (draw_state == WL_BRI - 1 && n_extra == 0)
+	    {
+		draw_state = WL_BRI;
+# ifdef FEAT_DIFF
+# endif
+		if (wp->w_p_bri && n_extra == 0 && row != startrow
+#ifdef FEAT_DIFF
+			&& filler_lines == 0
+#endif
+		   )
+		{
+		    char_attr = 0; /* was: hl_attr(HLF_AT); */
+#ifdef FEAT_DIFF
+		    if (diff_hlf != (hlf_T)0)
+			char_attr = hl_attr(diff_hlf);
+#endif
+		    p_extra = NUL;
+		    c_extra = ' ';
+		    n_extra = get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, FALSE));
+		    /* Correct end of highlighted area for 'breakindent',
+		     * required when 'linebreak' is also set. */
+		    if (tocol == vcol)
+			tocol += n_extra;
+		}
+	    }
+#endif
+
 #if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
 	    if (draw_state == WL_SBR - 1 && n_extra == 0)
 	    {
@@ -4382,11 +4425,12 @@ win_line(wp, lnum, startrow, endrow, noc
 		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr)
 							     && !wp->w_p_list)
 		{
-		    n_extra = win_lbr_chartabsize(wp, ptr - (
+		    char_u *p = ptr - (
 # ifdef FEAT_MBYTE
 				has_mbyte ? mb_l :
 # endif
-				1), (colnr_T)vcol, NULL) - 1;
+				1);
+		    n_extra = win_lbr_chartabsize(wp, p, (colnr_T)vcol, NULL, p) - 1;
 		    c_extra = ' ';
 		    if (vim_iswhite(c))
 		    {
diff --git a/src/structs.h b/src/structs.h
--- a/src/structs.h
+++ b/src/structs.h
@@ -134,6 +134,12 @@ typedef struct
     int		wo_arab;
 # define w_p_arab w_onebuf_opt.wo_arab	/* 'arabic' */
 #endif
+#ifdef FEAT_LINEBREAK
+    int		wo_bri;
+# define w_p_bri w_onebuf_opt.wo_bri	/* 'breakindent' */
+    char_u		*wo_briopt;
+# define w_p_briopt w_onebuf_opt.wo_briopt /* 'breakindentopt' */
+#endif
 #ifdef FEAT_DIFF
     int		wo_diff;
 # define w_p_diff w_onebuf_opt.wo_diff	/* 'diff' */
@@ -2189,6 +2195,11 @@ struct window_S
 #ifdef FEAT_SYN_HL
     int		*w_p_cc_cols;	    /* array of columns to highlight or NULL */
 #endif
+#ifdef FEAT_LINEBREAK
+    int		w_p_brimin;	    /* minimum width for breakindent */
+    int		w_p_brishift;	    /* additional shift for breakindent */
+    int		w_p_brisbr;	    /* sbr in 'briopt' */
+#endif
 
     /* transform a pointer to a "onebuf" option into a "allbuf" option */
 #define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
diff --git a/src/testdir/Make_amiga.mak b/src/testdir/Make_amiga.mak
--- a/src/testdir/Make_amiga.mak
+++ b/src/testdir/Make_amiga.mak
@@ -37,6 +37,7 @@ SCRIPTS = test1.out test3.out test4.out 
 		test99.out test100.out test101.out test102.out test103.out \
 		test104.out test105.out test106.out test107.out \
 		test_autoformat_join.out \
+		test_breakindent.out \
 		test_eval.out \
 		test_options.out
 
@@ -163,5 +164,6 @@ test105.out: test105.in
 test106.out: test106.in
 test107.out: test107.in
 test_autoformat_join.out: test_autoformat_join.in
+test_breakindent.out: test_breakindent.in
 test_eval.out: test_eval.in
 test_options.out: test_options.in
diff --git a/src/testdir/Make_dos.mak b/src/testdir/Make_dos.mak
--- a/src/testdir/Make_dos.mak
+++ b/src/testdir/Make_dos.mak
@@ -36,6 +36,7 @@ SCRIPTS =	test3.out test4.out test5.out 
 		test100.out test101.out test102.out test103.out test104.out \
 		test105.out test106.out  test107.out\
 		test_autoformat_join.out \
+		test_breakindent.out \
 		test_eval.out \
 		test_options.out
 
diff --git a/src/testdir/Make_ming.mak b/src/testdir/Make_ming.mak
--- a/src/testdir/Make_ming.mak
+++ b/src/testdir/Make_ming.mak
@@ -56,6 +56,7 @@ SCRIPTS =	test3.out test4.out test5.out 
 		test100.out test101.out test102.out test103.out test104.out \
 		test105.out test106.out test107.out \
 		test_autoformat_join.out \
+		test_breakindent.out \
 		test_eval.out \
 		test_options.out
 
diff --git a/src/testdir/Make_vms.mms b/src/testdir/Make_vms.mms
--- a/src/testdir/Make_vms.mms
+++ b/src/testdir/Make_vms.mms
@@ -97,6 +97,7 @@ SCRIPT = test1.out  test2.out  test3.out
 	 test100.out test101.out test103.out test104.out \
 	 test105.out test106.out test107.out \
 	 test_autoformat_join.out \
+	 test_breakindent.out \
 	 test_eval.out \
 	 test_options.out
 
diff --git a/src/testdir/Makefile b/src/testdir/Makefile
--- a/src/testdir/Makefile
+++ b/src/testdir/Makefile
@@ -34,6 +34,7 @@ SCRIPTS = test1.out test2.out test3.out 
 		test99.out test100.out test101.out test102.out test103.out \
 		test104.out test105.out test106.out test107.out \
 		test_autoformat_join.out \
+		test_breakindent.out \
 		test_eval.out \
 		test_options.out
 
diff --git a/src/testdir/test_breakindent.in b/src/testdir/test_breakindent.in
new file mode 100644
--- /dev/null
+++ b/src/testdir/test_breakindent.in
@@ -0,0 +1,79 @@
+Test for breakindent
+
+STARTTEST
+:so small.vim
+:if !exists("+breakindent") | e! test.ok | w! test.out | qa! | endif
+:10new|:vsp|:vert resize 20
+:put =\"\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP\"
+:set ts=4 sw=4 sts=4 breakindent
+:fu! ScreenChar(width)
+:	let c=''
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.'), i))
+:	endfor
+:       let c.="\n"
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.')+1, i))
+:	endfor
+:       let c.="\n"
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.')+2, i))
+:	endfor
+:	return c
+:endfu
+:fu DoRecordScreen()
+:	wincmd l
+:	$put =printf(\"\n%s\", g:test)
+:	$put =g:line1
+:	wincmd p
+:endfu
+:let g:test="Test 1: Simple breakindent"
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test="Test 2: Simple breakindent + sbr=>>"
+:set sbr=>>
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test ="Test 3: Simple breakindent + briopt:sbr"
+:set briopt=sbr sbr=++
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test ="Test 4: Simple breakindent + min width: 18"
+:set sbr= briopt=min:18
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test =" Test 5: Simple breakindent + shift by 2"
+:set briopt=shift:2
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test=" Test 6: Simple breakindent + shift by -1"
+:set briopt=shift:-1
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test=" Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr"
+:set briopt=shift:1,sbr nu sbr=? nuw=4
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr"
+:set briopt=shift:1,sbr nu sbr=# list
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 9: breakindent + shift by +1 + 'nu' + sbr=# list"
+:set briopt-=sbr
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n"
+:set cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:wincmd p
+:let g:test="\n Test 11: strdisplaywidth when breakindent is on"
+:set cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4
+:let text=getline(2) "skip leading tab when calculating text width
+:let width = strlen(text[1:])+indent(2)*4+strlen(&sbr)*3 " text wraps 3 times
+:$put =g:test
+:$put =printf(\"strdisplaywidth: %d == calculated: %d\", strdisplaywidth(text), width)
+:%w! test.out
+:qa!
+ENDTEST
+dummy text
diff --git a/src/testdir/test_breakindent.ok b/src/testdir/test_breakindent.ok
new file mode 100644
--- /dev/null
+++ b/src/testdir/test_breakindent.ok
@@ -0,0 +1,55 @@
+
+	abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP
+
+Test 1: Simple breakindent
+    abcd
+    qrst
+    GHIJ
+
+Test 2: Simple breakindent + sbr=>>
+    abcd
+    >>qr
+    >>EF
+
+Test 3: Simple breakindent + briopt:sbr
+    abcd
+++  qrst
+++  GHIJ
+
+Test 4: Simple breakindent + min width: 18
+    abcd
+  qrstuv
+  IJKLMN
+
+ Test 5: Simple breakindent + shift by 2
+    abcd
+      qr
+      EF
+
+ Test 6: Simple breakindent + shift by -1
+    abcd
+   qrstu
+   HIJKL
+
+ Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr
+  2     ab
+?        m
+?        x
+
+ Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr
+  2 ^Iabcd
+#      opq
+#      BCD
+
+ Test 9: breakindent + shift by +1 + 'nu' + sbr=# list
+  2 ^Iabcd
+       #op
+       #AB
+
+ Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n
+  2     ab
+~       mn
+~       yz
+
+ Test 11: strdisplaywidth when breakindent is on
+strdisplaywidth: 46 == calculated: 64
diff --git a/src/ui.c b/src/ui.c
--- a/src/ui.c
+++ b/src/ui.c
@@ -3167,7 +3167,7 @@ vcol2col(wp, lnum, vcol)
     start = ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
     while (count < vcol && *ptr != NUL)
     {
-	count += win_lbr_chartabsize(wp, ptr, count, NULL);
+	count += win_lbr_chartabsize(wp, ptr, count, NULL, start);
 	mb_ptr_adv(ptr);
     }
     return (int)(ptr - start);
diff --git a/src/version.c b/src/version.c
--- a/src/version.c
+++ b/src/version.c
@@ -1417,6 +1417,7 @@ static int included_patches[] =
  */
 static char *(extra_patches[]) =
 {   /* Add your patch description below this line */
+    "breakindent",
 /**/
     NULL
 };
