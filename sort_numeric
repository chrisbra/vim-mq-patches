# HG changeset patch
# Parent 5154251c8f234a5693cd5d065f77d70801e7b531

diff --git a/runtime/doc/eval.txt b/runtime/doc/eval.txt
--- a/runtime/doc/eval.txt
+++ b/runtime/doc/eval.txt
@@ -5633,7 +5633,12 @@ sort({list} [, {func} [, {dict}]])			*so
 		Numbers sort after Strings, |Lists| after Numbers.
 		For sorting text in the current buffer use |:sort|.
 
-		When {func} is given and it is one then case is ignored.
+		When {func} is given and it is is '1' or 'i' then case is
+		ignored. When {func} is given and it is 'n' then all items
+		will be sorted numerical (Implementation detail: This uses the
+		strtod() function to parse numbers, Strings, Lists, Dicts and
+		Funcrefs will be considered as being 0).
+
 		When {func} is a |Funcref| or a function name, this function
 		is called to compare items.  The function is invoked with two
 		items as argument and must return zero if they are equal, 1 or
diff --git a/src/eval.c b/src/eval.c
--- a/src/eval.c
+++ b/src/eval.c
@@ -17330,6 +17330,7 @@ static int
 	item_compare2 __ARGS((const void *s1, const void *s2));
 
 static int	item_compare_ic;
+static int	item_compare_numeric;
 static char_u	*item_compare_func;
 static dict_T	*item_compare_selfdict;
 static int	item_compare_func_err;
@@ -17359,10 +17360,20 @@ item_compare(s1, s2)
 	p1 = (char_u *)"";
     if (p2 == NULL)
 	p2 = (char_u *)"";
-    if (item_compare_ic)
-	res = STRICMP(p1, p2);
-    else
-	res = STRCMP(p1, p2);
+    if (!item_compare_numeric)
+    {
+	if (item_compare_ic)
+	    res = STRICMP(p1, p2);
+	else
+	    res = STRCMP(p1, p2);
+    }
+    else
+    {
+	double n1, n2;
+	n1 = strtod((char *)p1, (char **)&p1);
+	n2 = strtod((char *)p2, (char **)&p2);
+	res = n1 == n2 ? 0 : n1 > n2 ? 1 : -1;
+    }
     vim_free(tofree1);
     vim_free(tofree2);
     return res;
@@ -17439,6 +17450,7 @@ do_sort_uniq(argvars, rettv, sort)
 	    return;	/* short list sorts pretty quickly */
 
 	item_compare_ic = FALSE;
+	item_compare_numeric = FALSE;
 	item_compare_func = NULL;
 	item_compare_selfdict = NULL;
 	if (argvars[1].v_type != VAR_UNKNOWN)
@@ -17457,6 +17469,16 @@ do_sort_uniq(argvars, rettv, sort)
 		    item_compare_ic = TRUE;
 		else
 		    item_compare_func = get_tv_string(&argvars[1]);
+		if (*item_compare_func == 'n' && *(item_compare_func + 1) == NUL)
+		{
+		    item_compare_func = NULL;
+		    item_compare_numeric = TRUE;
+		}
+		else if (*item_compare_func == 'i' && *(item_compare_func + 1) == NUL)
+		{
+		    item_compare_func = NULL;
+		    item_compare_ic = TRUE;
+		}
 	    }
 
 	    if (argvars[2].v_type != VAR_UNKNOWN)
diff --git a/src/testdir/test55.in b/src/testdir/test55.in
--- a/src/testdir/test55.in
+++ b/src/testdir/test55.in
@@ -332,6 +332,10 @@ let l = [0, 1, 2, 3]
 :$put =string(reverse(sort(l)))
 :$put =string(sort(reverse(sort(l))))
 :$put =string(uniq(sort(l)))
+:let l=[7, 9, 18, 12, 22, 10.0e-16, -1, 0xff, 0, -0, 0.22, 'foo', 'FOOBAR',{}, []]
+:$put =string(sort(copy(l), 'n'))
+:$put =string(sort(copy(l), 'i'))
+:$put =string(sort(copy(l)))
 :"
 :" splitting a string to a List
 :$put =string(split('  aa  bb '))
diff --git a/src/testdir/test55.ok b/src/testdir/test55.ok
--- a/src/testdir/test55.ok
+++ b/src/testdir/test55.ok
@@ -101,6 +101,9 @@ caught a:000[3]
 [[0, 1, 2], [0, 1, 2], 4, 2, 2, 1.5, 'xaaa', 'x8', 'foo6', 'foo', 'foo', 'A11', '-0']
 ['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]]
 ['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 4, [0, 1, 2]]
+[-1, 0, 0, 'foo', 'FOOBAR', {}, [], 1.0e-15, 0.22, 7, 9, 12, 18, 22, 255]
+['foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
+['FOOBAR', 'foo', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
 ['aa', 'bb']
 ['aa', 'bb']
 ['', 'aa', 'bb', '']
