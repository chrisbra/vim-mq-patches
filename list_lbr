# HG changeset patch
# Parent 7e420d3c863ed3bf9f1907f56987a942bd6fbd57

diff --git a/src/charset.c b/src/charset.c
--- a/src/charset.c
+++ b/src/charset.c
@@ -1117,7 +1117,7 @@ win_lbr_chartabsize(wp, line, s, col, he
     if (wp->w_p_lbr
 	    && vim_isbreak(c)
 	    && !vim_isbreak(s[1])
-	    && !wp->w_p_list
+//	    && !wp->w_p_list
 	    && wp->w_p_wrap
 # ifdef FEAT_VERTSPLIT
 	    && wp->w_width != 0
diff --git a/src/screen.c b/src/screen.c
--- a/src/screen.c
+++ b/src/screen.c
@@ -2841,6 +2841,7 @@ win_line(wp, lnum, startrow, endrow, noc
     char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
     int		n_extra = 0;		/* number of extra chars */
     char_u	*p_extra = NULL;	/* string of extra chars, plus NUL */
+    char_u	*p_extra_free = NULL;   /* p_extra needs to be freed */
     int		c_extra = NUL;		/* extra chars, all the same */
     int		extra_attr = 0;		/* attributes when n_extra != 0 */
     static char_u *at_end_str = (char_u *)""; /* used for p_extra when
@@ -3003,7 +3004,11 @@ win_line(wp, lnum, startrow, endrow, noc
 #endif
 
     if (startrow > endrow)		/* past the end already! */
+    {
+	if (p_extra_free != NULL)
+	    vim_free(p_extra_free);
 	return startrow;
+    }
 
     row = startrow;
     screen_row = row + W_WINROW(wp);
@@ -4422,8 +4427,8 @@ win_line(wp, lnum, startrow, endrow, noc
 		/*
 		 * Found last space before word: check for line break.
 		 */
-		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr)
-							     && !wp->w_p_list)
+		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr))
+//							     && !wp->w_p_list)
 		{
 		    char_u *p = ptr - (
 # ifdef FEAT_MBYTE
@@ -4441,7 +4446,8 @@ win_line(wp, lnum, startrow, endrow, noc
 			    /* See "Tab alignment" below. */
 			    FIX_FOR_BOGUSCOLS;
 #endif
-			c = ' ';
+			if (!wp->w_p_list)
+			    c = ' ';
 		    }
 		}
 #endif
@@ -4481,9 +4487,39 @@ win_line(wp, lnum, startrow, endrow, noc
 		 */
 		if (c == TAB && (!wp->w_p_list || lcs_tab1))
 		{
+		    int tab_len = 0;
+		    int i;
 		    /* tab amount depends on current column */
-		    n_extra = (int)wp->w_buffer->b_p_ts
+			tab_len = (int)wp->w_buffer->b_p_ts
 					- vcol % (int)wp->w_buffer->b_p_ts - 1;
+		    if (!wp->w_p_lbr)
+		    /* tab amount depends on current column */
+			n_extra = tab_len;
+		    else
+		    {
+			char_u *p;
+			int len = n_extra;
+
+#ifdef FEAT_MBYTE
+			len = (tab_len * mb_char2len(lcs_tab2) + n_extra + 1);
+#endif
+			c = lcs_tab1;
+			p = alloc((unsigned)(len));
+			vim_memset(p, ' ', len);
+			p[len] = NUL;
+			p_extra_free = p;
+			for (i = 0; i < tab_len; i++)
+			{
+#ifdef FEAT_MBYTE
+			    mb_char2bytes(lcs_tab2, p);
+			    p+=mb_char2len(lcs_tab2);
+			    n_extra += mb_char2len(lcs_tab2) - 1;
+#else
+			    p[i] = lcs_tab2;
+#endif
+			}
+			p_extra = p_extra_free;
+		    }
 #ifdef FEAT_CONCEAL
 		    /* Tab alignment should be identical regardless of
 		     * 'conceallevel' value. So tab compensates of all
@@ -4499,8 +4535,11 @@ win_line(wp, lnum, startrow, endrow, noc
 		    if (wp->w_p_list)
 		    {
 			c = lcs_tab1;
-			c_extra = lcs_tab2;
-			n_attr = n_extra + 1;
+			if (wp->w_p_lbr)
+			    c_extra = NUL; /* using p_extra from above */
+			else
+			    c_extra = lcs_tab2;
+			n_attr = tab_len + 1;
 			extra_attr = hl_attr(HLF_8);
 			saved_attr2 = char_attr; /* save current attr */
 #ifdef FEAT_MBYTE
@@ -4596,9 +4635,22 @@ win_line(wp, lnum, startrow, endrow, noc
 		    if ((dy_flags & DY_UHEX) && wp->w_p_rl)
 			rl_mirror(p_extra);	/* reverse "<12>" */
 #endif
-		    n_extra = byte2cells(c) - 1;
 		    c_extra = NUL;
-		    c = *p_extra++;
+		    if (wp->w_p_lbr)
+		    {
+			char_u *p;
+			c = *p_extra;
+			p = alloc((unsigned)n_extra + 1);
+			vim_memset(p, ' ', n_extra);
+			STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);
+			p[n_extra] = NUL;
+			p_extra_free = p_extra = p;
+		    }
+		    else
+		    {
+			n_extra = byte2cells(c) - 1;
+			c = *p_extra++;
+		    }
 		    if (!attr_pri)
 		    {
 			n_attr = n_extra + 1;
@@ -5495,6 +5547,8 @@ win_line(wp, lnum, startrow, endrow, noc
     }
 #endif
 
+    if (p_extra_free != NULL)
+	vim_free(p_extra_free);
     return row;
 }
 
