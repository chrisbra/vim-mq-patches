diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -7594,7 +7594,7 @@
 						*'undolevels'* *'ul'*
 'undolevels' 'ul'	number	(default 100, 1000 for Unix, VMS,
 						Win32 and OS/2)
-			global
+			global or local to buffer |global-local|
 			{not in Vi}
 	Maximum number of changes that can be undone.  Since undo information
 	is kept in memory, higher numbers will cause more memory to be used
diff --git a/src/option.c b/src/option.c
--- a/src/option.c
+++ b/src/option.c
@@ -177,6 +177,7 @@
 #ifdef FEAT_PERSISTENT_UNDO
 # define PV_UDF		OPT_BUF(BV_UDF)
 #endif
+#define PV_UL		OPT_BOTH(OPT_BUF(BV_UL))
 #define PV_WM		OPT_BUF(BV_WM)
 
 /*
@@ -2683,7 +2684,7 @@
 #endif
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"undolevels",  "ul",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_ul, PV_NONE,
+			    (char_u *)&p_ul, PV_UL,
 			    {
 #if defined(UNIX) || defined(WIN3264) || defined(OS2) || defined(VMS)
 			    (char_u *)1000L,
@@ -3313,6 +3314,7 @@
 
     curbuf->b_p_initialized = TRUE;
     curbuf->b_p_ar = -1;	/* no local 'autoread' value */
+    curbuf->b_p_ul = -MAXLNUM;	/* no local 'undolevels' value */
     check_buf_options(curbuf);
     check_win_options(curwin);
     check_options();
@@ -4462,6 +4464,10 @@
 			if ((int *)varp == &curbuf->b_p_ar
 						    && opt_flags == OPT_LOCAL)
 			    value = -1;
+			/* For 'undolevels' -MAXLNUM means to use global value. */
+			if ((long *)varp == &curbuf->b_p_ul
+						    && opt_flags == OPT_LOCAL)
+			    value = -MAXLNUM;
 			else
 			    value = *(int *)get_varp_scope(&(options[opt_idx]),
 								  OPT_GLOBAL);
@@ -8460,12 +8466,21 @@
 #endif
 
     /* sync undo before 'undolevels' changes */
-    else if (pp == &p_ul)
+    else if (pp == &curbuf->b_p_ul || pp == &p_ul)
     {
 	/* use the old value, otherwise u_sync() may not work properly */
-	p_ul = old_value;
-	u_sync(TRUE);
-	p_ul = value;
+	if (pp == &p_ul)
+	{
+	    p_ul = old_value;
+	    u_sync(TRUE);
+	    p_ul = value;
+	}
+	else
+	{
+	    curbuf->b_p_ul = old_value;
+	    u_sync(TRUE);
+	    curbuf->b_p_ul = value;
+	}
     }
 
 #ifdef FEAT_LINEBREAK
@@ -9803,6 +9818,7 @@
 	    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);
 	    case PV_PATH: return (char_u *)&(curbuf->b_p_path);
 	    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);
+	    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);
 	    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);
 #ifdef FEAT_FIND_ID
 	    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);
@@ -9851,8 +9867,11 @@
 				    ? (char_u *)&(curbuf->b_p_path) : p->var;
 	case PV_AR:	return curbuf->b_p_ar >= 0
 				    ? (char_u *)&(curbuf->b_p_ar) : p->var;
+	case PV_UL:	return curbuf->b_p_ul > -MAXLNUM
+				    ? (char_u *)&(curbuf->b_p_ul) : p->var;
 	case PV_TAGS:	return *curbuf->b_p_tags != NUL
 				    ? (char_u *)&(curbuf->b_p_tags) : p->var;
+
 #ifdef FEAT_FIND_ID
 	case PV_DEF:	return *curbuf->b_p_def != NUL
 				    ? (char_u *)&(curbuf->b_p_def) : p->var;
@@ -10425,6 +10444,7 @@
 	    /* options that are normally global but also have a local value
 	     * are not copied, start using the global value */
 	    buf->b_p_ar = -1;
+	    buf->b_p_ul = -MAXLNUM;
 #ifdef FEAT_QUICKFIX
 	    buf->b_p_gp = empty_option;
 	    buf->b_p_mp = empty_option;
diff --git a/src/option.h b/src/option.h
--- a/src/option.h
+++ b/src/option.h
@@ -1031,6 +1031,7 @@
     , BV_TW
     , BV_TX
     , BV_UDF
+    , BV_UL
     , BV_WM
     , BV_COUNT	    /* must be the last one */
 };
diff --git a/src/structs.h b/src/structs.h
--- a/src/structs.h
+++ b/src/structs.h
@@ -1627,6 +1627,7 @@
     char_u	*b_p_dict;	/* 'dictionary' local value */
     char_u	*b_p_tsr;	/* 'thesaurus' local value */
 #endif
+    long	b_p_ul;         /* 'undolevels' */
 #ifdef FEAT_PERSISTENT_UNDO
     int		b_p_udf;	/* 'undofile' */
 #endif
diff --git a/src/undo.c b/src/undo.c
--- a/src/undo.c
+++ b/src/undo.c
@@ -357,7 +357,9 @@
     u_entry_T	*uep;
     u_entry_T	*prev_uep;
     long	size;
-
+    long        b_p_ul;
+
+    b_p_ul = (curbuf->b_p_ul > -MAXLNUM ? curbuf->b_p_ul : p_ul);
     if (!reload)
     {
 	/* When making changes is not allowed return FAIL.  It's a crude way
@@ -419,7 +421,7 @@
 	curbuf->b_new_change = TRUE;
 #endif
 
-	if (p_ul >= 0)
+	if (b_p_ul >= 0)
 	{
 	    /*
 	     * Make a new header entry.  Do this first so that we don't mess
@@ -449,7 +451,7 @@
 	/*
 	 * free headers to keep the size right
 	 */
-	while (curbuf->b_u_numhead > p_ul && curbuf->b_u_oldhead != NULL)
+	while (curbuf->b_u_numhead > b_p_ul && curbuf->b_u_oldhead != NULL)
 	{
 	    u_header_T	    *uhfree = curbuf->b_u_oldhead;
 
@@ -530,7 +532,7 @@
     }
     else
     {
-	if (p_ul < 0)		/* no undo at all */
+	if (b_p_ul < 0)		/* no undo at all */
 	    return OK;
 
 	/*
@@ -1952,10 +1954,12 @@
     int startcount;
 {
     int count = startcount;
+    long b_p_ul;
 
     if (!undo_allowed())
 	return;
 
+    b_p_ul = (curbuf->b_p_ul > -MAXLNUM ? curbuf->b_p_ul : p_ul);
     u_newcount = 0;
     u_oldcount = 0;
     if (curbuf->b_ml.ml_flags & ML_EMPTY)
@@ -1972,7 +1976,7 @@
 	{
 	    if (curbuf->b_u_curhead == NULL)		/* first undo */
 		curbuf->b_u_curhead = curbuf->b_u_newhead;
-	    else if (p_ul > 0)				/* multi level undo */
+	    else if (b_p_ul > 0)		/* multi level undo */
 		/* get next undo */
 		curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;
 	    /* nothing to undo */
@@ -1993,7 +1997,7 @@
 	}
 	else
 	{
-	    if (curbuf->b_u_curhead == NULL || p_ul <= 0)
+	    if (curbuf->b_u_curhead == NULL || b_p_ul <= 0)
 	    {
 		beep_flush();	/* nothing to redo */
 		if (count == startcount - 1)
@@ -2744,14 +2748,16 @@
 u_sync(force)
     int	    force;	/* Also sync when no_u_sync is set. */
 {
+    long b_p_ul;
     /* Skip it when already synced or syncing is disabled. */
     if (curbuf->b_u_synced || (!force && no_u_sync > 0))
 	return;
+    b_p_ul = (curbuf->b_p_ul > -MAXLNUM ? curbuf->b_p_ul : p_ul);
 #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
     if (im_is_preediting())
 	return;		    /* XIM is busy, don't break an undo sequence */
 #endif
-    if (p_ul < 0)
+    if (b_p_ul < 0)
 	curbuf->b_u_synced = TRUE;  /* no entries, nothing to do */
     else
     {
@@ -2902,6 +2908,8 @@
 ex_undojoin(eap)
     exarg_T *eap UNUSED;
 {
+    long        b_p_ul;
+
     if (curbuf->b_u_newhead == NULL)
 	return;		    /* nothing changed before */
     if (curbuf->b_u_curhead != NULL)
@@ -2911,7 +2919,9 @@
     }
     if (!curbuf->b_u_synced)
 	return;		    /* already unsynced */
-    if (p_ul < 0)
+
+    b_p_ul = (curbuf->b_p_ul > -MAXLNUM ? curbuf->b_p_ul : p_ul);
+    if (b_p_ul < 0)
 	return;		    /* no entries, nothing to do */
     else
     {
