Fix that setmatches() can't cope with matches returned from matchaddpos()

# HG changeset patch
# Parent 75dadafa65f881db352b566b06a223ad54a636ec

diff --git a/src/eval.c b/src/eval.c
--- a/src/eval.c
+++ b/src/eval.c
@@ -17118,6 +17118,7 @@ f_setmatches(argvars, rettv)
     list_T	*l;
     listitem_T	*li;
     dict_T	*d;
+    list_T	*s = NULL;
 
     rettv->vval.v_number = -1;
     if (argvars[0].v_type != VAR_LIST)
@@ -17140,7 +17141,8 @@ f_setmatches(argvars, rettv)
 		return;
 	    }
 	    if (!(dict_find(d, (char_u *)"group", -1) != NULL
-			&& dict_find(d, (char_u *)"pattern", -1) != NULL
+			&& (dict_find(d, (char_u *)"pattern", -1) != NULL ||
+			    dict_find(d, (char_u *)"pos1", -1) != NULL)
 			&& dict_find(d, (char_u *)"priority", -1) != NULL
 			&& dict_find(d, (char_u *)"id", -1) != NULL))
 	    {
@@ -17150,15 +17152,62 @@ f_setmatches(argvars, rettv)
 	    li = li->li_next;
 	}
 
+
 	clear_matches(curwin);
 	li = l->lv_first;
 	while (li != NULL)
 	{
+	    int	    i = 0;
+	    char_u  buf[4];
+	    dictitem_T  *di;
+
 	    d = li->li_tv.vval.v_dict;
-	    match_add(curwin, get_dict_string(d, (char_u *)"group", FALSE),
+
+	    if (!(dict_find(d, (char_u *)"pattern", -1) != NULL))
+	    {
+		if (s == NULL)
+		{
+		    s = list_alloc();
+		    if (s == NULL)
+			return;
+		}
+
+		/* match from matchaddpos() */
+		for (i=1; i<9; i++)
+		{
+		    sprintf((char *)buf, (char *)"pos%d", i);
+		    if ((di = dict_find(d, (char_u *)buf, -1)) != NULL)
+		    {
+			if (s == NULL)
+			{
+			    s = list_alloc();
+			    if (s == NULL)
+				return;
+			}
+			if (di->di_tv.v_type != VAR_LIST)
+			    return;
+
+			list_append_tv(s, &di->di_tv);
+			s->lv_refcount++;
+		    }
+		    else
+			break;
+		}
+	    }
+	    if (!i)
+		match_add(curwin, get_dict_string(d, (char_u *)"group", FALSE),
 		    get_dict_string(d, (char_u *)"pattern", FALSE),
 		    (int)get_dict_number(d, (char_u *)"priority"),
 		    (int)get_dict_number(d, (char_u *)"id"), NULL);
+	    else
+	    {
+		match_add(curwin, get_dict_string(d, (char_u *)"group", FALSE),
+		    NULL, (int)get_dict_number(d, (char_u *)"priority"),
+		    (int)get_dict_number(d, (char_u *)"id"), s);
+		list_unref(s);
+		s = NULL;
+	    }
+
 	    li = li->li_next;
 	}
 	rettv->vval.v_number = 0;
diff --git a/src/testdir/test63.in b/src/testdir/test63.in
--- a/src/testdir/test63.in
+++ b/src/testdir/test63.in
@@ -187,7 +187,12 @@ STARTTEST
 :else
 :  let @r .= "FAILED: " . v4 . "/" . v5 . "/" . v6 . "/" . v7 . "/" . v8 . "/" . v9 . "/" . v10 . "\n"
 :endif
+:" Check, that setmatches() can correctly restore the matches from matchaddpos()
+:call matchadd('MyGroup1', '\%2lmatchadd')
+:let m=getmatches()
 :call clearmatches()
+:call setmatches(m)
+:let @r .= string(getmatches())."\n"
 G"rp
 :/^Results/,$wq! test.out
 ENDTEST
diff --git a/src/testdir/test63.ok b/src/testdir/test63.ok
--- a/src/testdir/test63.ok
+++ b/src/testdir/test63.ok
@@ -14,3 +14,4 @@ Results of test63:
 OK
 [{'group': 'MyGroup1', 'id': 11, 'priority': 10, 'pos1': [1, 4, 2], 'pos2': [1, 9, 2]}]
 OK
+[{'group': 'MyGroup1', 'id': 11, 'priority': 10, 'pos1': [1, 4, 2], 'pos2': [1, 9, 2]}, {'group': 'MyGroup1', 'pattern': '\%2lmatchadd', 'priority': 10, 'id': 12}]
