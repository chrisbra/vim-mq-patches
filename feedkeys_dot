This patch fixes the following problem:

Consider this buffer content:
------------
a b c
a b c
------------
" map . to this:
nnoremap . :call feedkeys(".", "n")<cr>
" At line one do this:
qqdw.ifoo<esc>q
" register q should contain:
dw.ifoo
" replay macro at line two:
@q
" line 2 should look like line 1:
fooc
" and not like this.
fofooob c

This happens, because when the call to feedkeys() is executed, the
'.' will be appended to the last typed/stuffed chars while in fact
it should be placed at the current position, since you want to repeat
previous command and not the command that happens to be the last one
typed (in the mapping).

The fix is to put the '.' at the current typebuf.offset
rather at the end. I am not sure, if this should happen only when
'.' is the only char or whenever the mapped key string just starts
with '.' (but I tend to believe the second case).

# HG changeset patch
# Parent 399f0d3ca0b032add3e9f80da6096c3cf781880f

diff --git a/src/eval.c b/src/eval.c
--- a/src/eval.c
+++ b/src/eval.c
@@ -10528,12 +10528,15 @@ f_feedkeys(argvars, rettv)
 	}
 
 	/* Need to escape K_SPECIAL and CSI before putting the string in the
-	 * typeahead buffer. */
+	 * typeahead buffer. Special attention needs to be payed, for the '.'
+	 * command. If that is used, it needs to be added at the current
+	 * position in the typebuf and not at the end (which means, it
+	 * would redo the wrong command */
 	keys_esc = vim_strsave_escape_csi(keys);
 	if (keys_esc != NULL)
 	{
 	    ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),
-					       typebuf.tb_len, !typed, FALSE);
+				*keys_esc == ('.' ? 0 : typebuf.tb_len), !typed, FALSE);
 	    vim_free(keys_esc);
 	    if (vgetc_busy)
 		typebuf_was_filled = TRUE;
