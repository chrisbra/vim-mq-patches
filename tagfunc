From 47ac4af73d734bdb08d7f5171584b6b3b4318e61 Mon Sep 17 00:00:00 2001
From: Christian Brabandt <cb@256bit.org>
Date: Tue, 13 Dec 2016 22:28:09 +0100
Subject: [PATCH] Add tagfunc feature
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit adds the tagfunc feature from the old vim_extended
repository.

,----[ :h 'tagfunc' ]-
| 							*'tagfunc'* *'tfu'*
| 'tagfunc' 'tfu'		string	(default: empty)
| 			local to buffer
| 			{not in Vi}
| 			{not available when compiled without the +eval
| 			or +insert_expand feature}
| 	This option specifies a function to be used to perform tag searches.
| 	The function should take two parameters, the first of which is the
| 	pattern to be searched, while the second is a set of flags which may
| 	be used by the function to decide on its behaviour. Currently the
| 	following flags may appear:
| 		'c' - indicates that the context around the cursor position
| 		      can be used to generate more accurate results,
| 		'i' - the function is being called during insert-mode
| 		      completion.
| 	See |tag-function| for an explanation of what the function should
| 	return and an example of such a function.
`----

Repository:
https://github.com/chrisbra/vim-mq-patches
git://github.com/chrisbra/vim-mq-patches.git

Filename:
tagfunc

Latest update for:
vim-8.0.0515

Bug reports:
http://www.vim.org/maillist.php

License & Copyright:
© 2010 Robert Webb, Lech Lorens
─────────────────────────────────────────────────────────────────────────────
diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
index 9a88edb1a..f2d9c0a29 100644
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -7585,6 +7585,24 @@ A jump table for the options with a short description can be found at |Q_op|.
 	NOTE: This option is set to the Vi default value when 'compatible' is
 	set and to the Vim default value when 'compatible' is reset.
 
+							*'tagfunc'* *'tfu'*
+'tagfunc' 'tfu'		string	(default: empty)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the +eval
+			or +insert_expand feature}
+	This option specifies a function to be used to perform tag searches.
+	The function should take two parameters, the first of which is the
+	pattern to be searched, while the second is a set of flags which may
+	be used by the function to decide on its behaviour. Currently the
+	following flags may appear:
+		'c' - indicates that the context around the cursor position
+		      can be used to generate more accurate results,
+		'i' - the function is being called during insert-mode
+		      completion.
+	See |tag-function| for an explanation of what the function should
+	return and an example of such a function.
+
 						*'taglength'* *'tl'*
 'taglength' 'tl'	number	(default 0)
 			global
diff --git a/runtime/doc/tagsrch.txt b/runtime/doc/tagsrch.txt
index 3ef372ef8..3c4ad9346 100644
--- a/runtime/doc/tagsrch.txt
+++ b/runtime/doc/tagsrch.txt
@@ -14,6 +14,7 @@ See section |29.1| of the user manual for an introduction.
 4. Tags details			|tag-details|
 5. Tags file format		|tags-file-format|
 6. Include file searches	|include-search|
+7. Programmable tag search	|tag-function|
 
 ==============================================================================
 1. Jump to a tag					*tag-commands*
@@ -853,4 +854,57 @@ Common arguments for the commands above:
 <	For a ":djump", ":dsplit", ":dlist" and ":dsearch" command the pattern
 	is used as a literal string, not as a search pattern.
 
+==============================================================================
+7. Programmable tag search					*tag-function*
+
+It is possible to provide Vim with a script which will generate a list of tags
+used for commands like |:tag|, |:tselect| and normal mode commands like
+|CTRL-]|. The Vim script function used for generating the taglist is specified
+by setting the 'tagfunc' option. The function will be called with two
+arguments:
+   a:pattern - the tag identifier used during the tag search,
+   a:flags   - a list of flags to control the function behaviour.
+
+Currently the only flag that may be passed to the tag function is 'c' which
+indicates that the function was invoked due to a normal command being
+processed (mnemonic: the tag function may use the Context around the cursor to
+perform a better job of generating the tag list.
+
+Note that when 'tagfunc' is set, the priority of the tags described in
+|tag-priority| does not apply. Instead, the priority is exactly as the
+ordering of the elements in the list returned by the function.
+
+The function should return a list of dictionaries. Each of the dictionaries
+must at least include the following entries:
+	name		Name of the tag.
+	filename	Name of the file where the tag is
+			defined.  It is either relative to the
+			current directory or a full path.
+	cmd		Ex command used to locate the tag in the file. This
+			can be either an ex search pattern, a line number or
+			a line number followed by a byte number.
+Note that the format of the result is similar to that of |taglist()|,
+which makes it possible to use its output to generate the result.
+
+
+The following is a hypothetical example of a function used for 'tagfunc'. It
+uses the output of |taglist()| to generate the result: a list of tags in the
+inverse order of file names.
+
+>
+	function! TagFunc(pattern, flags)
+	  function! CompareFilenames(item1, item2)
+	    let f1 = a:item1['filename']
+	    let f2 = a:item2['filename']
+	    return f1 >=# f2 ?
+			\ -1 : f1 <=# f2 ? 1 : 0
+	  endfunction
+
+	  let result = taglist(a:pattern)
+	  call sort(result, "CompareFilenames")
+
+	  return result
+	endfunc
+	set tagfunc=TagFunc
+<
  vim:tw=78:ts=8:ft=help:norl:
diff --git a/runtime/optwin.vim b/runtime/optwin.vim
index 2cbbd288b..82effe92b 100644
--- a/runtime/optwin.vim
+++ b/runtime/optwin.vim
@@ -301,6 +301,9 @@ call append("$", "tagstack\ta :tag command will use the tagstack")
 call <SID>BinOptionG("tgst", &tgst)
 call append("$", "showfulltag\twhen completing tags in Insert mode show more info")
 call <SID>BinOptionG("sft", &sft)
+call append("$", "tagfunc\ta function to be used to peform tag searches")
+call append("$", "\t(local to buffer)")
+call <SID>OptionL("tagfunc")
 if has("cscope")
   call append("$", "cscopeprg\tcommand for executing cscope")
   call <SID>OptionG("csprg", &csprg)
diff --git a/src/buffer.c b/src/buffer.c
index 83d74a379..38fb625ab 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -2232,6 +2232,7 @@ free_buf_options(
 #ifdef FEAT_COMPL_FUNC
     clear_string_option(&buf->b_p_cfu);
     clear_string_option(&buf->b_p_ofu);
+    clear_string_option(&buf->b_p_tfu);
 #endif
 #ifdef FEAT_QUICKFIX
     clear_string_option(&buf->b_p_gp);
diff --git a/src/dict.c b/src/dict.c
index a26419b6d..c1c8161f2 100644
--- a/src/dict.c
+++ b/src/dict.c
@@ -364,6 +364,57 @@ dict_add_list(dict_T *d, char *key, list_T *list)
     }
     return OK;
 }
+/* Initializes a data structure used for iterating over dictionary items in
+ * dict_iterate_next().
+ */
+    void
+dict_iterate_start(typval_T *argvars, struct dict_iterator_S *iter)
+{
+    dict_T	*d;
+
+    if (argvars[0].v_type != VAR_DICT)
+    {
+	iter->items = 0;
+	return;
+    }
+
+    if ((d = argvars[0].vval.v_dict) == NULL)
+    {
+	iter->items = 0;
+	return;
+    }
+
+    iter->items = (int)d->dv_hashtab.ht_used;
+    iter->hi = d->dv_hashtab.ht_array;
+}
+
+/* Allows iterating over the items stored in a dictionary.
+ * Returns the pointer to the key, *tv_result is set to point to the value
+ * for that key.
+ * If there are no more items, NULL is returned.
+ * iter should be initialized with dict_iterate_start() before calling this
+ * function for the first time.
+ */
+    char_u*
+dict_iterate_next(struct dict_iterator_S *iter, typval_T **tv_result)
+{
+    dictitem_T	*di;
+    char_u      *result;
+
+    if (iter->items <= 0)
+	return NULL;
+
+    while (HASHITEM_EMPTY(iter->hi))
+	++iter->hi;
+
+    di = HI2DI(iter->hi);
+    result = di->di_key;
+    *tv_result = &di->di_tv;
+
+    --iter->items;
+    ++iter->hi;
+    return result;
+}
 
 /*
  * Add a dict entry to dictionary "d".
diff --git a/src/edit.c b/src/edit.c
index cdde11e40..61dcc1326 100644
--- a/src/edit.c
+++ b/src/edit.c
@@ -4428,6 +4428,7 @@ ins_compl_get_exp(pos_T *ini)
 
 	    /* Find up to TAG_MANY matches.  Avoids that an enormous number
 	     * of matches is found when compl_pattern is empty */
+	    g_tag_at_cursor = 1;
 	    if (find_tags(compl_pattern, &num_matches, &matches,
 		    TAG_REGEXP | TAG_NAMES | TAG_NOIC |
 		    TAG_INS_COMP | (ctrl_x_mode ? TAG_VERBOSE : 0),
@@ -4435,6 +4436,7 @@ ins_compl_get_exp(pos_T *ini)
 	    {
 		ins_compl_add_matches(num_matches, matches, p_ic);
 	    }
+	    g_tag_at_cursor = 0;
 	    p_ic = save_p_ic;
 	    break;
 
diff --git a/src/ex_cmds.c b/src/ex_cmds.c
index 6940e5527..528de8e35 100644
--- a/src/ex_cmds.c
+++ b/src/ex_cmds.c
@@ -6696,7 +6696,7 @@ find_help_tags(
 
     *matches = (char_u **)"";
     *num_matches = 0;
-    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE;
+    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_DONT_USE_TFU;
     if (keep_lang)
 	flags |= TAG_KEEP_LANG;
     if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK
diff --git a/src/globals.h b/src/globals.h
index f8186630f..2942fe40e 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -1101,6 +1101,9 @@ EXTERN int	g_do_tagpreview INIT(= 0);  /* for tag preview commands:
 					       height of preview window */
 # endif
 #endif
+EXTERN int	g_tag_at_cursor INIT(= 0);  /* whether the tag command comes
+					       from the command line (0) or was
+					       invoked as a normal command (1) */
 EXTERN int	replace_offset INIT(= 0);   /* offset for replace_push() */
 
 EXTERN char_u	*escape_chars INIT(= (char_u *)" \t\\\"|");
diff --git a/src/normal.c b/src/normal.c
index 53bda6cc7..28ec30802 100644
--- a/src/normal.c
+++ b/src/normal.c
@@ -5801,7 +5801,11 @@ nv_ident(cmdarg_T *cap)
 	(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);
     }
     else
-	do_cmdline_cmd(buf);
+    {
+	g_tag_at_cursor = 1;
+ 	do_cmdline_cmd(buf);
+	g_tag_at_cursor = 0;
+    }
 
     vim_free(buf);
 }
diff --git a/src/option.c b/src/option.c
index c40454844..60b17f069 100644
--- a/src/option.c
+++ b/src/option.c
@@ -175,6 +175,9 @@
 #endif
 #define PV_SW		OPT_BUF(BV_SW)
 #define PV_SWF		OPT_BUF(BV_SWF)
+#ifdef FEAT_COMPL_FUNC
+# define PV_TFU		OPT_BUF(BV_TFU)
+#endif
 #define PV_TAGS		OPT_BOTH(OPT_BUF(BV_TAGS))
 #define PV_TC		OPT_BOTH(OPT_BUF(BV_TC))
 #define PV_TS		OPT_BUF(BV_TS)
@@ -309,6 +312,7 @@ static char_u	*p_cpt;
 #ifdef FEAT_COMPL_FUNC
 static char_u	*p_cfu;
 static char_u	*p_ofu;
+static char_u	*p_tfu;
 #endif
 static int	p_eol;
 static int	p_fixeol;
@@ -2722,6 +2726,15 @@ static struct vimoption options[] =
     {"tagcase",	    "tc",   P_STRING|P_VIM,
 			    (char_u *)&p_tc, PV_TC,
 			    {(char_u *)"followic", (char_u *)"followic"} SCRIPTID_INIT},
+    {"tagfunc",    "tfu",   P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
+#ifdef FEAT_COMPL_FUNC
+			    (char_u *)&p_tfu, PV_TFU,
+			    {(char_u *)"", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
     {"taglength",   "tl",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tl, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
@@ -5672,6 +5685,7 @@ check_buf_options(buf_T *buf)
 #ifdef FEAT_COMPL_FUNC
     check_string_option(&buf->b_p_cfu);
     check_string_option(&buf->b_p_ofu);
+    check_string_option(&buf->b_p_tfu);
 #endif
 #ifdef FEAT_KEYMAP
     check_string_option(&buf->b_p_keymap);
@@ -10671,6 +10685,7 @@ get_varp(struct vimoption *p)
 #ifdef FEAT_COMPL_FUNC
 	case PV_CFU:	return (char_u *)&(curbuf->b_p_cfu);
 	case PV_OFU:	return (char_u *)&(curbuf->b_p_ofu);
+	case PV_TFU:	return (char_u *)&(curbuf->b_p_tfu);
 #endif
 	case PV_EOL:	return (char_u *)&(curbuf->b_p_eol);
 	case PV_FIXEOL:	return (char_u *)&(curbuf->b_p_fixeol);
@@ -11065,6 +11080,7 @@ buf_copy_options(buf_T *buf, int flags)
 #ifdef FEAT_COMPL_FUNC
 	    buf->b_p_cfu = vim_strsave(p_cfu);
 	    buf->b_p_ofu = vim_strsave(p_ofu);
+	    buf->b_p_tfu = vim_strsave(p_tfu);
 #endif
 	    buf->b_p_sts = p_sts;
 	    buf->b_p_sts_nopaste = p_sts_nopaste;
diff --git a/src/option.h b/src/option.h
index 2c6aeef03..615880714 100644
--- a/src/option.h
+++ b/src/option.h
@@ -1104,6 +1104,9 @@ enum
 #endif
     , BV_SW
     , BV_SWF
+#ifdef FEAT_COMPL_FUNC
+    , BV_TFU
+#endif
     , BV_TAGS
     , BV_TC
     , BV_TS
diff --git a/src/proto/dict.pro b/src/proto/dict.pro
index 61f4dfa5b..9d4a6a00e 100644
--- a/src/proto/dict.pro
+++ b/src/proto/dict.pro
@@ -14,6 +14,8 @@ int dict_add_list(dict_T *d, char *key, list_T *list);
 int dict_add_dict(dict_T *d, char *key, dict_T *dict);
 long dict_len(dict_T *d);
 dictitem_T *dict_find(dict_T *d, char_u *key, int len);
+void dict_iterate_start(typval_T *argvars, struct dict_iterator_S *iter);
+char_u *dict_iterate_next(struct dict_iterator_S *iter, typval_T **tv_result);
 char_u *get_dict_string(dict_T *d, char_u *key, int save);
 varnumber_T get_dict_number(dict_T *d, char_u *key);
 char_u *dict2string(typval_T *tv, int copyID, int restore_copyID);
diff --git a/src/structs.h b/src/structs.h
index 475280af1..a81a34226 100644
--- a/src/structs.h
+++ b/src/structs.h
@@ -1734,6 +1734,16 @@ typedef struct list_stack_S
     struct list_stack_S	*prev;
 } list_stack_T;
 
+/*
+ * Structure used for iterating over dictionary items.
+ * Initialize with dict_iterate_start().
+ */
+struct dict_iterator_S
+{
+    int         items;
+    hashitem_T	*hi;
+};
+
 /* values for b_syn_spell: what to do with toplevel text */
 #define SYNSPL_DEFAULT	0	/* spell check if @Spell not defined */
 #define SYNSPL_TOP	1	/* spell check toplevel text */
@@ -2091,6 +2101,7 @@ struct file_buffer
 #ifdef FEAT_COMPL_FUNC
     char_u	*b_p_cfu;	/* 'completefunc' */
     char_u	*b_p_ofu;	/* 'omnifunc' */
+    char_u	*b_p_tfu;	/* 'tagfunc' */
 #endif
     int		b_p_eol;	/* 'endofline' */
     int		b_p_fixeol;	/* 'fixendofline' */
diff --git a/src/tag.c b/src/tag.c
index e2795b805..ac08cef81 100644
--- a/src/tag.c
+++ b/src/tag.c
@@ -26,7 +26,8 @@ typedef struct tag_pointers
     char_u	*command;	/* first char of command */
     /* filled in by parse_match(): */
     char_u	*command_end;	/* first char after command */
-    char_u	*tag_fname;	/* file name of the tags file */
+    char_u	*tag_fname;	/* file name of the tags file. This is used
+				 * when 'tr' is set. */
 #ifdef FEAT_EMACS_TAGS
     int		is_etag;	/* TRUE for emacs tag */
 #endif
@@ -148,6 +149,7 @@ do_tag(
     int		skip_msg = FALSE;
     char_u	*buf_ffname = curbuf->b_ffname;	    /* name to use for
 						       priority computation */
+    int         use_tfu = 1;
 
     /* remember the matches for the last used tag */
     static int		num_matches = 0;
@@ -172,6 +174,7 @@ do_tag(
     {
 	type = DT_TAG;
 	no_regexp = TRUE;
+	use_tfu = 0;
     }
 
     prev_num_matches = num_matches;
@@ -527,6 +530,10 @@ do_tag(
 #endif
 	    if (verbose)
 		flags |= TAG_VERBOSE;
+
+	    if (!use_tfu)
+		flags |= TAG_DONT_USE_TFU;
+
 	    if (find_tags(name, &new_num_matches, &new_matches, flags,
 					    max_num_matches, buf_ffname) == OK
 		    && new_num_matches < max_num_matches)
@@ -1233,6 +1240,196 @@ prepare_pats(pat_T *pats, int has_re)
 	pats->regmatch.regprog = NULL;
 }
 
+struct match_found
+{
+    int	len;			/* nr of chars of match[] to be compared */
+    char_u	match[1];	/* actually longer */
+};
+
+#ifdef FEAT_COMPL_FUNC
+/*
+ * find_tfu_tags() - call the user-defined function to generate a list of tags
+ *                   used by find_tags().
+ *
+ * Return OK if at least 1 tag has been successfully found, FAIL otherwise.
+ * pat         - used as the pattern supplied to the user-defined function,
+ * ga          - the tags will be placed here,
+ * match_count - here the number of tags found will be placed,
+ * flags       - used to compose a string containing flags passed to the function.
+ */
+    static int
+find_tfu_tags(char_u *pat, garray_T *ga, int *match_count, int flags)
+{
+    pos_T       pos;
+    list_T      *taglist;
+    listitem_T  *item;
+    int         ntags = 0;
+    int         result = FAIL;
+    char_u      *args[2];
+    char_u      flagString[3];
+
+    if (*curbuf->b_p_tfu == NUL)
+	goto done;
+
+    args[0] = pat;
+    args[1] = flagString;
+
+    vim_snprintf((char *)flagString, sizeof(flagString),
+		 "%s%s",
+		 g_tag_at_cursor      ? "c": "",
+		 flags & TAG_INS_COMP ? "i": "");
+
+    pos = curwin->w_cursor;
+    taglist = call_func_retlist(curbuf->b_p_tfu, 2, args, FALSE);
+    curwin->w_cursor = pos;	/* restore the cursor position */
+
+    if (taglist == NULL)
+	goto done;
+
+    for (item = taglist->lv_first; item != NULL; item = item->li_next)
+    {
+	struct match_found     *mfp;
+	char_u                 *res_name, *res_fname, *res_cmd, *res_kind;
+	int                    len;
+	struct dict_iterator_S iter;
+	char_u                 *dict_key;
+	typval_T               *tv;
+	int                    has_extra = 0;
+
+	if (item->li_tv.v_type != VAR_DICT)
+	    continue;
+
+#ifdef FEAT_EMACS_TAGS
+	len = 3;
+#else
+	len = 2;
+#endif
+
+	res_name = NULL;
+	res_fname = NULL;
+	res_cmd = NULL;
+	res_kind = NULL;
+
+	dict_iterate_start(&item->li_tv, &iter);
+	while (NULL != (dict_key = dict_iterate_next(&iter, &tv)))
+	{
+	    if (tv->v_type != VAR_STRING)
+		continue;
+
+	    len += STRLEN(tv->vval.v_string) + 1; /* Space for "\tVALUE". */
+	    if (!STRCMP(dict_key, "name"))
+	    {
+		res_name = tv->vval.v_string;
+		continue;
+	    }
+	    if (!STRCMP(dict_key, "filename"))
+	    {
+		res_fname = tv->vval.v_string;
+		continue;
+	    }
+	    if (!STRCMP(dict_key, "cmd"))
+	    {
+		res_cmd = tv->vval.v_string;
+		continue;
+	    }
+	    has_extra = 1;
+	    if (!STRCMP(dict_key, "kind"))
+	    {
+		res_kind = tv->vval.v_string;
+		continue;
+	    }
+	    len += STRLEN(dict_key) + 1; /* Other elements will be stored as "\tKEY:VALUE".
+					  * Allocate space for the key and the colon. */
+	}
+
+	if (has_extra)
+	    len += 2; /* need space for ;" */
+
+	if (!res_name || !res_fname || !res_cmd)
+	    continue;
+
+	mfp = (struct match_found *)alloc(
+			(int)sizeof(struct match_found) + len);
+	if (mfp != NULL)
+	{
+	    char_u *p;
+	    mfp->len = len;
+	    p = mfp->match;
+	    p[0] = 0;   /* mtt */
+	    p[1] = NUL; /* no tag file name */
+	    p = p + 2;
+#ifdef FEAT_EMACS_TAGS
+	    *p = NUL;
+	    ++p;
+#endif
+
+	    STRCPY(p, res_name);
+	    p += STRLEN(p);
+
+	    *p++ = TAB;
+	    STRCPY(p, res_fname);
+	    p += STRLEN(p);
+
+	    *p++ = TAB;
+	    STRCPY(p, res_cmd);
+	    p += STRLEN(p);
+
+	    if (has_extra)
+	    {
+		STRCPY(p, ";\"");
+		p += STRLEN(p);
+
+		if (res_kind)
+		{
+		    *p++ = TAB;
+		    STRCPY(p, res_kind);
+		    p += STRLEN(p);
+		}
+
+		dict_iterate_start(&item->li_tv, &iter);
+		while (NULL != (dict_key = dict_iterate_next(&iter, &tv)))
+		{
+		    if (tv->v_type != VAR_STRING)
+			continue;
+
+		    if (!STRCMP(dict_key, "name"))
+			continue;
+		    if (!STRCMP(dict_key, "filename"))
+			continue;
+		    if (!STRCMP(dict_key, "cmd"))
+			continue;
+		    if (!STRCMP(dict_key, "kind"))
+			continue;
+
+		    *p++ = TAB;
+		    STRCPY(p, dict_key);
+		    p += STRLEN(p);
+		    STRCPY(p, ":");
+		    p += STRLEN(p);
+		    STRCPY(p, tv->vval.v_string);
+		    p += STRLEN(p);
+		}
+	    }
+
+	    /* FIXME:2010-04-24:llorens: Don't add identical matches. */
+	    if (ga_grow(ga, 1) == OK)
+	    {
+		((struct match_found **)(ga->ga_data)) [ga->ga_len++] = mfp;
+		++ntags;
+		result = OK;
+	    }
+	    else
+		vim_free(mfp);
+	}
+    }
+
+    list_free(taglist);
+done:
+    *match_count = ntags;
+    return result;
+}
+#endif
+
 /*
  * find_tags() - search for tags in tags files
  *
@@ -1258,6 +1455,7 @@ prepare_pats(pat_T *pats, int has_re)
  * TAG_NOIC	  don't always ignore case
  * TAG_KEEP_LANG  keep language
  * TAG_CSCOPE	  use cscope results for tags
+ * TAG_DONT_USE_TFU  do not invoke the 'tagfunc' command
  */
     int
 find_tags(
@@ -1377,6 +1575,10 @@ find_tags(
     int		use_cscope = (flags & TAG_CSCOPE);
 #endif
     int		verbose = (flags & TAG_VERBOSE);
+#ifdef FEAT_COMPL_FUNC
+    int         use_tfu = ((flags & TAG_DONT_USE_TFU) == 0);
+    static int  tfu_call_level = 0;
+#endif
     int		save_p_ic = p_ic;
 
     /*
@@ -1474,6 +1676,16 @@ find_tags(
     vim_memset(&search_info, 0, (size_t)1);
 #endif
 
+#ifdef FEAT_COMPL_FUNC
+    if (*curbuf->b_p_tfu != NUL && use_tfu && tfu_call_level == 0)
+    {
+	++tfu_call_level;
+	retval = find_tfu_tags(pat, &ga_match[0], &match_count, flags);
+	--tfu_call_level;
+	goto findtag_end;
+    }
+#endif
+
     /*
      * When finding a specified number of matches, first try with matching
      * case, so binary search can be used, and try ignore-case matches in a
@@ -3799,11 +4011,11 @@ expand_tags(
 	tagnmflag = 0;
     if (pat[0] == '/')
 	ret = find_tags(pat + 1, num_file, file,
-		TAG_REGEXP | tagnmflag | TAG_VERBOSE,
+		TAG_REGEXP | tagnmflag | TAG_VERBOSE | TAG_DONT_USE_TFU,
 		TAG_MANY, curbuf->b_ffname);
     else
 	ret = find_tags(pat, num_file, file,
-		TAG_REGEXP | tagnmflag | TAG_VERBOSE | TAG_NOIC,
+		TAG_REGEXP | tagnmflag | TAG_VERBOSE | TAG_DONT_USE_TFU | TAG_NOIC,
 		TAG_MANY, curbuf->b_ffname);
     if (ret == OK && !tagnames)
     {
diff --git a/src/vim.h b/src/vim.h
index 57866ef53..b6c90d880 100644
--- a/src/vim.h
+++ b/src/vim.h
@@ -1169,20 +1169,21 @@ typedef struct {
 /*
  * flags for find_tags().
  */
-#define TAG_HELP	1	/* only search for help tags */
-#define TAG_NAMES	2	/* only return name of tag */
-#define	TAG_REGEXP	4	/* use tag pattern as regexp */
-#define	TAG_NOIC	8	/* don't always ignore case */
+#define TAG_HELP		1	/* only search for help tags */
+#define TAG_NAMES		2	/* only return name of tag */
+#define	TAG_REGEXP		4	/* use tag pattern as regexp */
+#define	TAG_NOIC		8	/* don't always ignore case */
 #ifdef FEAT_CSCOPE
-# define TAG_CSCOPE	16	/* cscope tag */
+# define TAG_CSCOPE		16	/* cscope tag */
 #endif
-#define TAG_VERBOSE	32	/* message verbosity */
-#define TAG_INS_COMP	64	/* Currently doing insert completion */
-#define TAG_KEEP_LANG	128	/* keep current language */
-
-#define TAG_MANY	300	/* When finding many tags (for completion),
-				   find up to this many tags */
+#define TAG_VERBOSE		32	/* message verbosity */
+#define TAG_INS_COMP		64	/* Currently doing insert completion */
+#define TAG_KEEP_LANG		128	/* keep current language */
+#define TAG_DONT_USE_TFU	256	/* whether 'tagfunc' should be evaluated */
 
+#define TAG_MANY		300	/* When finding many tags (for completion),
+					   find up to this many tags */
+ 
 /*
  * Types of dialogs passed to do_vim_dialog().
  */
