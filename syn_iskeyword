Make syntax highlighting independent of the 'isk' setting.

Currently setting 'isk' option has - among others - an unwanted side
effect on the syntax highlighting.

For example by removing the '_' from the 'iskeyword' setting, defined
syntax keywords start matching where they didn't match before.

E.g. in a SQL buffer,

CREATE TABLE FOOBAR(
     CRTD_BY     VARCHAR2(100));

Setting :setlocal isk-=_ will make the 'BY' highlighted as syntax
keyword. I believe this is unwanted and therefore I propose the
following enhancement:

Add a new syntax command ":syn iskeyword" for specifically
setting the 'iskeyword' setting to sane values. So in a syntax file, one
could set: >
    :syn iskeyword @,48-57,_,192-255
<
and have syntax highlighting make work as expected independent on the
users choice of setting the 'isk' setting. If this is not done, syntax
highlighting will depend on the users 'isk' setting as before.

The current syntax iskeyword setting can be seen by using: >
     :syn iskeyword
<

And it can be reset to the old behaviour using: >
     :syn iskeyword clear
<

This is a proof of concept patch, that does this.

Patch:      syn_iskeyword
Repository: https://github.com/chrisbra/vim-mq-patches
Discussion: https://groups.google.com/d/msg/vim_dev/aptsKXTwCwo/6SsR9AECDwAJ

Copyright & License:
© 2015 C.Brabandt Vim
──────────────────────────────────────────────────────────────────────────
# HG changeset patch
# Parent bb59c2451c1f67d5cd99d997502c6948e0abc25c

diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -4489,6 +4489,8 @@ A jump table for the options with a shor
 	'*', '"' and '|' (so that CTRL-] on a command finds the help for that
 	command).
 	When the 'lisp' option is on the '-' character is always included.
+	This option also influences syntax highlighting, see |:syn-iskeyword|
+	how to circumvent it.
 	NOTE: This option is set to the Vi default value when 'compatible' is
 	set and to the Vim default value when 'compatible' is reset.
 
diff --git a/runtime/doc/syntax.txt b/runtime/doc/syntax.txt
--- a/runtime/doc/syntax.txt
+++ b/runtime/doc/syntax.txt
@@ -3444,6 +3444,25 @@ SPELL CHECKING						*:syn-spell*
 
 	To activate spell checking the 'spell' option must be set.
 
+SYNTAX ISKEYWORD SETTING				*:syn-iskeyword*
+
+:sy[ntax] iskeyword [clear | {option}]
+	This defines the 'iskeyword' option for the syntax highlighting.
+
+	clear:		Reset the syntax 'iskeyword' option to its buffer
+			local value.
+	{option}        Set the syntax 'iskeyword' option to the new value.
+
+	If no option is given, the current setting will be output.
+
+	Setting this option, influences what |/\k| matches in syntax patterns
+	and also determines where |:syn-keywords| will be checked for a new
+	match.
+
+	It is recommended when writing syntax files, to set the syntax
+	'iskeyword' option to a sane value (e.g. the global 'isk' option) to
+	have the syntax highlighting work independently of the users 'isk'
+	settings.
 
 DEFINING KEYWORDS					*:syn-keyword*
 
@@ -3475,6 +3494,7 @@ DEFINING KEYWORDS					*:syn-keyword*
 	isn't, the keyword will never be recognized.
 	Multi-byte characters can also be used.  These do not have to be in
 	'iskeyword'.
+	See |:syn-iskeyword| for defining syntax specific iskeyword settings.
 
 	A keyword always has higher priority than a match or region, the
 	keyword is used if more than one item matches.	Keywords do not nest
diff --git a/src/buffer.c b/src/buffer.c
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -1955,6 +1955,7 @@ free_buf_options(buf, free_p_ff)
     clear_string_option(&buf->b_p_nf);
 #ifdef FEAT_SYN_HL
     clear_string_option(&buf->b_p_syn);
+    clear_string_option(&buf->b_s.b_syn_isk);
 #endif
 #ifdef FEAT_SPELL
     clear_string_option(&buf->b_s.b_p_spc);
diff --git a/src/option.c b/src/option.c
--- a/src/option.c
+++ b/src/option.c
@@ -5484,6 +5484,7 @@ check_buf_options(buf)
 #endif
 #ifdef FEAT_SYN_HL
     check_string_option(&buf->b_p_syn);
+    check_string_option(&buf->b_s.b_syn_isk);
 #endif
 #ifdef FEAT_SPELL
     check_string_option(&buf->b_s.b_p_spc);
@@ -10779,6 +10780,7 @@ buf_copy_options(buf, flags)
 	    /* Don't copy 'syntax', it must be set */
 	    buf->b_p_syn = empty_option;
 	    buf->b_p_smc = p_smc;
+	    buf->b_s.b_syn_isk = vim_strsave(p_isk);
 #endif
 #ifdef FEAT_SPELL
 	    buf->b_s.b_p_spc = vim_strsave(p_spc);
diff --git a/src/structs.h b/src/structs.h
--- a/src/structs.h
+++ b/src/structs.h
@@ -1361,6 +1361,8 @@ typedef struct {
 #if !defined(FEAT_SYN_HL) && !defined(FEAT_SPELL)
     int		dummy;
 #endif
+    char_u	b_syn_chartab[32];	/* syntax iskeyword option */
+    char_u	*b_syn_isk;		/* iskeyword option */
 } synblock_T;
 
 
diff --git a/src/syntax.c b/src/syntax.c
--- a/src/syntax.c
+++ b/src/syntax.c
@@ -993,14 +993,23 @@ syn_match_linecont(lnum)
 {
     regmmatch_T regmatch;
     int r;
+    char_u	buf_chartab[32];  /* chartab array for syn iskyeyword */
 
     if (syn_block->b_syn_linecont_prog != NULL)
     {
+	/* use syntax iskeyword option */
+	if (syn_block->b_syn_isk != empty_option)
+	{
+	    memcpy(buf_chartab, syn_buf->b_chartab, (size_t)32);
+	    memcpy(syn_buf->b_chartab, syn_win->w_s->b_syn_chartab, (size_t)32);
+	}
 	regmatch.rmm_ic = syn_block->b_syn_linecont_ic;
 	regmatch.regprog = syn_block->b_syn_linecont_prog;
 	r = syn_regexec(&regmatch, lnum, (colnr_T)0,
 				IF_SYN_TIME(&syn_block->b_syn_linecont_time));
 	syn_block->b_syn_linecont_prog = regmatch.regprog;
+	if (syn_win->w_s->b_syn_isk != empty_option)
+	    memcpy(syn_buf->b_chartab, buf_chartab, (size_t)32);
 	return r;
     }
     return FALSE;
@@ -1891,6 +1900,7 @@ syn_current_attr(syncing, displaying, ca
     lpos_T	pos;
     int		lc_col;
     reg_extmatch_T *cur_extmatch = NULL;
+    char_u	buf_chartab[32];  /* chartab array for syn iskyeyword */
     char_u	*line;		/* current line.  NOTE: becomes invalid after
 				   looking for a pattern match! */
 
@@ -1945,6 +1955,12 @@ syn_current_attr(syncing, displaying, ca
      * avoid matching the same item in the same position twice. */
     ga_init2(&zero_width_next_ga, (int)sizeof(int), 10);
 
+    /* use syntax iskeyword option */
+    if (syn_win->w_s->b_syn_isk != empty_option)
+    {
+	memcpy(buf_chartab, syn_buf->b_chartab, (size_t)32);
+	memcpy(syn_buf->b_chartab, syn_win->w_s->b_syn_chartab, (size_t)32);
+    }
     /*
      * Repeat matching keywords and patterns, to find contained items at the
      * same column.  This stops when there are no extra matches at the current
@@ -1956,6 +1972,7 @@ syn_current_attr(syncing, displaying, ca
 	keep_next_list = FALSE;
 	syn_id = 0;
 
+
 	/*
 	 * 1. Check for a current state.
 	 *    Only when there is no current state, or if the current state may
@@ -2309,6 +2326,9 @@ syn_current_attr(syncing, displaying, ca
 
     } while (found_match);
 
+    if (syn_win->w_s->b_syn_isk != empty_option)
+	memcpy(syn_buf->b_chartab, buf_chartab, (size_t)32);
+
     /*
      * Use attributes from the current state, if within its highlighting.
      * If not, use attributes from the current-but-one state, etc.
@@ -2915,6 +2935,7 @@ find_endpos(idx, startpos, m_endpos, hl_
     lpos_T	pos;
     char_u	*line;
     int		had_match = FALSE;
+    char_u	buf_chartab[32];  /* chartab array for syn option iskyeyword */
 
     /* just in case we are invoked for a keyword */
     if (idx < 0)
@@ -2961,6 +2982,12 @@ find_endpos(idx, startpos, m_endpos, hl_
     matchcol = startpos->col;	/* start looking for a match at sstart */
     start_idx = idx;		/* remember the first END pattern. */
     best_regmatch.startpos[0].col = 0;		/* avoid compiler warning */
+    /* use syntax iskeyword option */
+    if (syn_win->w_s->b_syn_isk != empty_option)
+    {
+	memcpy(buf_chartab, syn_buf->b_chartab, (size_t)32);
+	memcpy(syn_buf->b_chartab, syn_win->w_s->b_syn_chartab, (size_t)32);
+    }
     for (;;)
     {
 	/*
@@ -3114,6 +3141,9 @@ find_endpos(idx, startpos, m_endpos, hl_
     if (!had_match)
 	m_endpos->lnum = 0;
 
+    if (syn_win->w_s->b_syn_isk != empty_option)
+	memcpy(syn_buf->b_chartab, buf_chartab, (size_t)32);
+
     /* Remove external matches. */
     unref_extmatch(re_extmatch_in);
     re_extmatch_in = NULL;
@@ -3479,6 +3509,57 @@ syn_cmd_spell(eap, syncing)
 }
 
 /*
+ * Handle ":syntax iskeyword" command.
+ */
+    static void
+syn_cmd_iskeyword(eap, syncing)
+    exarg_T	*eap;
+    int		syncing UNUSED;
+{
+    char_u	*arg = eap->arg;
+    char_u	g_chartab[32];
+    char_u	s_chartab[32];
+    char_u	*syn_isk;
+
+    if (eap->skip)
+	return;
+
+    arg = skipwhite(arg);
+    if (*arg == NUL)
+    {
+	MSG_PUTS("\n");
+	MSG_PUTS(_("syntax iskeyword "));
+	if (curwin->w_s->b_syn_isk != empty_option)
+	    msg_outtrans(curwin->w_s->b_syn_isk);
+	else
+	    msg_outtrans((char_u *)"not set");
+    }
+    else
+    {
+	if (STRNICMP(arg, "clear", 5) == 0)
+	{
+	    memcpy(curwin->w_s->b_syn_chartab, curbuf->b_chartab, (size_t)32);
+	    clear_string_option(&curwin->w_s->b_syn_isk);
+	}
+	else
+	{
+	    memcpy(g_chartab, curbuf->b_chartab, (size_t)32);
+	    memcpy(curbuf->b_chartab, s_chartab, (size_t)32);
+	    syn_isk = curbuf->b_p_isk;
+	    curbuf->b_p_isk = vim_strsave(arg);
+
+	    buf_init_chartab(curbuf, FALSE);
+	    memcpy(curwin->w_s->b_syn_chartab, curbuf->b_chartab, (size_t)32);
+	    memcpy(curbuf->b_chartab, g_chartab, (size_t)32);
+	    clear_string_option(&curwin->w_s->b_syn_isk);
+	    curwin->w_s->b_syn_isk = curbuf->b_p_isk;
+	    curbuf->b_p_isk = syn_isk;
+	}
+    }
+    redraw_win_later(curwin, NOT_VALID);
+}
+
+/*
  * Clear all syntax info for one buffer.
  */
     void
@@ -3520,6 +3601,7 @@ syntax_clear(block)
 #ifdef FEAT_FOLDING
     block->b_syn_folditems = 0;
 #endif
+    clear_string_option(&block->b_syn_isk);
 
     /* free the stored states */
     syn_stack_free_all(block);
@@ -3566,6 +3648,8 @@ syntax_sync_clear()
     curwin->w_s->b_syn_linecont_prog = NULL;
     vim_free(curwin->w_s->b_syn_linecont_pat);
     curwin->w_s->b_syn_linecont_pat = NULL;
+    vim_free(curwin->w_s->b_syn_isk);
+    curwin->w_s->b_syn_isk = NULL;
 
     syn_stack_free_all(curwin->w_s);		/* Need to recompute all syntax. */
 }
@@ -3774,6 +3858,7 @@ syn_cmd_reset(eap, syncing)
     eap->nextcmd = check_nextcmd(eap->arg);
     if (!eap->skip)
     {
+	clear_string_option(&curwin->w_s->b_syn_isk);
 	set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"reset");
 	do_cmdline_cmd((char_u *)"runtime! syntax/syncolor.vim");
 	do_unlet((char_u *)"g:syntax_cmd", TRUE);
@@ -6245,6 +6330,7 @@ static struct subcommand subcommands[] =
     {"conceal",		syn_cmd_conceal},
     {"enable",		syn_cmd_enable},
     {"include",		syn_cmd_include},
+    {"iskeyword",	syn_cmd_iskeyword},
     {"keyword",		syn_cmd_keyword},
     {"list",		syn_cmd_list},
     {"manual",		syn_cmd_manual},
@@ -6323,6 +6409,7 @@ ex_ownsyntax(eap)
 	clear_string_option(&curwin->w_s->b_p_spf);
 	clear_string_option(&curwin->w_s->b_p_spl);
 #endif
+	clear_string_option(&curwin->w_s->b_syn_isk);
     }
 
     /* save value of b:current_syntax */
diff --git a/src/testdir/Make_amiga.mak b/src/testdir/Make_amiga.mak
--- a/src/testdir/Make_amiga.mak
+++ b/src/testdir/Make_amiga.mak
@@ -66,6 +66,7 @@ SCRIPTS = test1.out test3.out test4.out 
 		test_search_mbyte.out \
 		test_set.out \
 		test_signs.out \
+		test_syntax.out \
 		test_textobjects.out \
 		test_utf8.out
 
@@ -221,5 +222,6 @@ test_ruby.out: test_ruby.in
 test_search_mbyte.out: test_search_mbyte.in
 test_set.out: test_set.in
 test_signs.out: test_signs.in
+test_syntax.out: test_syntax.in
 test_textobjects.out: test_textobjects.in
 test_utf8.out: test_utf8.in
diff --git a/src/testdir/Make_dos.mak b/src/testdir/Make_dos.mak
--- a/src/testdir/Make_dos.mak
+++ b/src/testdir/Make_dos.mak
@@ -65,6 +65,7 @@ SCRIPTS =	test3.out test4.out test5.out 
 		test_search_mbyte.out \
 		test_set.out \
 		test_signs.out \
+		test_syntax.out \
 		test_textobjects.out \
 		test_utf8.out
 
diff --git a/src/testdir/Make_ming.mak b/src/testdir/Make_ming.mak
--- a/src/testdir/Make_ming.mak
+++ b/src/testdir/Make_ming.mak
@@ -87,6 +87,7 @@ SCRIPTS =	test3.out test4.out test5.out 
 		test_search_mbyte.out \
 		test_set.out \
 		test_signs.out \
+		test_syntax.out \
 		test_textobjects.out \
 		test_utf8.out
 
diff --git a/src/testdir/Make_os2.mak b/src/testdir/Make_os2.mak
--- a/src/testdir/Make_os2.mak
+++ b/src/testdir/Make_os2.mak
@@ -67,6 +67,7 @@ SCRIPTS = test1.out test3.out test4.out 
 		test_search_mbyte.out \
 		test_set.out \
 		test_signs.out \
+		test_syntax.out \
 		test_textobjects.out \
 		test_utf8.out
 
diff --git a/src/testdir/Make_vms.mms b/src/testdir/Make_vms.mms
--- a/src/testdir/Make_vms.mms
+++ b/src/testdir/Make_vms.mms
@@ -126,6 +126,7 @@ SCRIPT = test1.out  test2.out  test3.out
 	 test_search_mbyte.out \
 	 test_set.out \
 	 test_signs.out \
+	 test_syntax.out \
 	 test_textobjects.out \
 	 test_utf8.out
 
diff --git a/src/testdir/Makefile b/src/testdir/Makefile
--- a/src/testdir/Makefile
+++ b/src/testdir/Makefile
@@ -63,6 +63,7 @@ SCRIPTS = test1.out test2.out test3.out 
 		test_search_mbyte.out \
 		test_set.out \
 		test_signs.out \
+		test_syntax.out \
 		test_textobjects.out \
 		test_utf8.out
 
diff --git a/src/testdir/test_syntax.in b/src/testdir/test_syntax.in
new file mode 100644
--- /dev/null
+++ b/src/testdir/test_syntax.in
@@ -0,0 +1,56 @@
+Test for syntax and syntax iskeyword option
+
+STARTTEST
+:so small.vim
+:if !has("syntax") | e! test.ok | w! test.out | qa! | endif
+:fu! GetSyntaxItem(pat)
+:	let c=''
+:       let a=['a', getreg('a'), getregtype('a')]
+:       0
+:       redraw!
+:       call search(a:pat, 'W')
+:       let synid = synID(line('.'),col('.'),1)
+:       while synid == synID(line('.'),col('.'),1)
+:           norm! v"ay
+:           " stop at whitespace
+:           if @a=~#'\s'
+:              break
+:           endif
+:           let c.=@a
+:           norm! l
+:       endw
+:       call call('setreg', a)
+:       0
+:	return c
+:endfu
+:fu! Compare(syntax, search)
+:    return [g:name, printf("Syntax match: '%s'", a:syntax), printf("Search match: '%s'", a:search)]
+:endfu
+:let @b=''
+:g/^CREATE/.,/;/y a
+:new| $put a
+:$put =''
+:syntax on
+:set ft=sql
+:syn match SYN /C\k\+\>/
+:hi link SYN ErrorMsg
+:let a1=GetSyntaxItem('DLTD')
+:/\<D\k\+\>/:norm! ygn
+:let a2=@0
+:syn iskeyword @,48-57,_,192-255
+:setlocal isk-=_
+:let b1=GetSyntaxItem('DLTD')
+:/\<D\k\+\>/:norm! ygn
+:let b2=@0
+:let g:name='#1: init, both matches should be the same'
+:call append('$', Compare(a1,a2))
+:let g:name='#2: init, syntax same as before, search match should have stopped before _'
+:call append('$', Compare(b1,b2))
+:%w! test.out
+:qa!
+ENDTEST
+
+CREATE TABLE FOOBAR(
+    DLTD_BY VARCHAR2(100)
+);
+
diff --git a/src/testdir/test_syntax.ok b/src/testdir/test_syntax.ok
new file mode 100644
--- /dev/null
+++ b/src/testdir/test_syntax.ok
@@ -0,0 +1,11 @@
+
+CREATE TABLE FOOBAR(
+    DLTD_BY VARCHAR2(100)
+);
+
+#1: init, both matches should be the same
+Syntax match: 'DLTD_BY'
+Search match: 'DLTD_BY'
+#2: init, syntax same as before, search match should have stopped before _
+Syntax match: 'DLTD_BY'
+Search match: 'DLTD'
