# HG changeset patch
# Parent e796bd0195e6fb08982beb4d7774a5adac634cbd

diff --git a/runtime/doc/quickfix.txt b/runtime/doc/quickfix.txt
--- a/runtime/doc/quickfix.txt
+++ b/runtime/doc/quickfix.txt
@@ -607,23 +607,26 @@ 5.1 using Vim's internal grep
 			pattern must start with an ID character.
 			Example: >
 				:vimgrep Error *.c
-<
+
+:vim[grep][!] {pattern} 
+			Like above, but only search current buffer.
+
 							*:lv* *:lvimgrep*
-:lv[imgrep][!] /{pattern}/[g][j] {file} ...
-:lv[imgrep][!] {pattern} {file} ...
+:lv[imgrep][!] /{pattern}/[g][j] [{file} ...]
+:lv[imgrep][!] {pattern} [{file} ...]
 			Same as ":vimgrep", except the location list for the
 			current window is used instead of the quickfix list.
 
 						*:vimgrepa* *:vimgrepadd*
-:vimgrepa[dd][!] /{pattern}/[g][j] {file} ...
-:vimgrepa[dd][!] {pattern} {file} ...
+:vimgrepa[dd][!] /{pattern}/[g][j] [{file} ...]
+:vimgrepa[dd][!] {pattern} [{file} ...]
 			Just like ":vimgrep", but instead of making a new list
 			of errors the matches are appended to the current
 			list.
 
 						*:lvimgrepa* *:lvimgrepadd*
-:lvimgrepa[dd][!] /{pattern}/[g][j] {file} ...
-:lvimgrepa[dd][!] {pattern} {file} ...
+:lvimgrepa[dd][!] /{pattern}/[g][j] [{file} ...]
+:lvimgrepa[dd][!] {pattern} [{file} ...]
 			Same as ":vimgrepadd", except the location list for
 			the current window is used instead of the quickfix
 			list.
diff --git a/src/quickfix.c b/src/quickfix.c
--- a/src/quickfix.c
+++ b/src/quickfix.c
@@ -3175,6 +3175,7 @@ ex_vimgrep(eap)
     char_u	*target_dir = NULL;
 #ifdef FEAT_AUTOCMD
     char_u	*au_name =  NULL;
+    int		only_curbuf = FALSE;
 
     switch (eap->cmdidx)
     {
@@ -3242,8 +3243,8 @@ ex_vimgrep(eap)
     p = skipwhite(p);
     if (*p == NUL)
     {
-	EMSG(_("E683: File name missing or invalid pattern"));
-	goto theend;
+	only_curbuf = TRUE;
+	fcount = 1;
     }
 
     if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd &&
@@ -3258,7 +3259,7 @@ ex_vimgrep(eap)
 	    ;
 
     /* parse the list of arguments */
-    if (get_arglist_exp(p, &fcount, &fnames, TRUE) == FAIL)
+    if (!only_curbuf && get_arglist_exp(p, &fcount, &fnames, TRUE) == FAIL)
 	goto theend;
     if (fcount == 0)
     {
@@ -3284,29 +3285,38 @@ ex_vimgrep(eap)
     seconds = (time_t)0;
     for (fi = 0; fi < fcount && !got_int && tomatch > 0; ++fi)
     {
-	fname = shorten_fname1(fnames[fi]);
-	if (time(NULL) > seconds)
+	if (!only_curbuf)
 	{
-	    /* Display the file name every second or so, show the user we are
-	     * working on it. */
-	    seconds = time(NULL);
-	    msg_start();
-	    p = msg_strtrunc(fname, TRUE);
-	    if (p == NULL)
-		msg_outtrans(fname);
-	    else
+	    fname = shorten_fname1(fnames[fi]);
+	    if (time(NULL) > seconds)
 	    {
-		msg_outtrans(p);
-		vim_free(p);
+		/* Display the file name every second or so, show the user we are
+		* working on it. */
+		seconds = time(NULL);
+		msg_start();
+		p = msg_strtrunc(fname, TRUE);
+		if (p == NULL)
+		    msg_outtrans(fname);
+		else
+		{
+		    msg_outtrans(p);
+		    vim_free(p);
+		}
+		msg_clr_eos();
+		msg_didout = FALSE;	    /* overwrite this message */
+		msg_nowait = TRUE;	    /* don't wait for this message */
+		msg_col = 0;
+		out_flush();
 	    }
-	    msg_clr_eos();
-	    msg_didout = FALSE;	    /* overwrite this message */
-	    msg_nowait = TRUE;	    /* don't wait for this message */
-	    msg_col = 0;
-	    out_flush();
+
+	    buf = buflist_findname_exp(fnames[fi]);
 	}
-
-	buf = buflist_findname_exp(fnames[fi]);
+	else
+	{
+	    buf = curbuf;
+	    fname = NULL;
+	}
+
 	if (buf == NULL || buf->b_ml.ml_mfp == NULL)
 	{
 	    /* Remember that a buffer with this name already exists. */
@@ -3472,7 +3482,8 @@ ex_vimgrep(eap)
 	}
     }
 
-    FreeWild(fcount, fnames);
+    if (!only_curbuf)
+	FreeWild(fcount, fnames);
 
     qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
     qi->qf_lists[qi->qf_curlist].qf_ptr = qi->qf_lists[qi->qf_curlist].qf_start;
